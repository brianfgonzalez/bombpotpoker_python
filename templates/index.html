<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bombpot Poker</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Luckiest+Guy&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', 'Segoe UI', 'Arial', sans-serif;
            background: #1a2a3a;
            background-image: url("/static/casino-felt.jpg");
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            color: #f3f4f6;
        }
        /* Overlap cards in player hand, leftmost card on top */
        .overlap-cards {
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
        }
        .overlap-cards > * {
            margin-right: -1.7rem;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .overlap-cards > *:first-child {
            margin-right: 0;
        }
        /* Style for select dropdown to ensure readable text */
        .custom-select {
            background-color: #232946 !important;
            color: #fff !important;
            border: 1px solid #393e46;
        }
        /* Make all dropdown options white text on dark background */
        .custom-select option, select.custom-select option {
            background-color: #232946 !important;
            color: #fff !important;
        }
        /* Poker chip effect for buttons */
        .poker-chip {
            background: radial-gradient(circle at 60% 40%, #f7c873 0%, #eab308 80%, #b8860b 100%);
            color: #232946;
            border: 2px solid #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            font-weight: bold;
            letter-spacing: 1px;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .poker-chip:hover {
            transform: scale(1.05);
            background: radial-gradient(circle at 60% 40%, #ffe082 0%, #facc15 80%, #b8860b 100%);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        .poker-chip:active {
            transform: scale(0.97);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        /* Card style enhancements */
        .poker-card {
            background: linear-gradient(135deg, #fff 60%, #e2e8f0 100%);
            border: 2px solid #393e46;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            color: #232946;
            transition: transform 0.3s cubic-bezier(.4,2,.2,1), box-shadow 0.2s;
            transform-style: preserve-3d;
            perspective: 600px;
            min-height: 3.5rem; /* Ensure enough height for rank/suit */
            font-weight: bold;
        }
        .poker-card.flip-animate {
            transform: rotateY(180deg);
        }
        .poker-card:hover {
            transform: scale(1.08) rotate(-2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 2;
        }
        .poker-card.red {
            color: #e3342f;
            border-color: #e3342f;
        }
        .poker-card.black {
            color: #232946;
            border-color: #232946;
        }
        .poker-card.flipped {
            background: repeating-linear-gradient(
                135deg,
                #232946,
                #232946 10px,
                #393e46 10px,
                #393e46 20px
            );
            color: transparent;
            border-color: #393e46;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .overlap-cards > * {
                margin-right: -1.2rem;
            }
            .poker-card {
                min-height: 5.2rem !important;
                width: 4rem !important;
                height: 5.2rem !important;
            }
            .w-14, .h-24 {
                width: 4rem !important;
                height: 5.2rem !important;
            }
            .flex-col.md\:flex-row {
                flex-direction: column !important;
            }
            .gap-10 {
                gap: 1.5rem !important;
            }
            .px-4, .pt-6 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
                padding-top: 0.5rem !important;
            }
            .py-8 {
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
            }
            .mb-4, .mb-10 {
                margin-bottom: 1rem !important;
            }
            .rounded-xl {
                border-radius: 0.75rem !important;
            }
            .text-4xl {
                font-size: 2rem !important;
            }
            .text-lg {
                font-size: 1rem !important;
            }
            .w-14, .h-24 {
                width: 2.5rem !important;
                height: 3.5rem !important;
            }
            .p-6, .p-8 {
                padding: 1rem !important;
            }
            .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
        }
        .reveal-glow {
            box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15;
            border-color: #ffe082 !important;
            background: linear-gradient(135deg, #ffe082 60%, #facc15 100%) !important;
            color: #232946 !important;
            animation: glow-pulse 1s infinite alternate;
        }
        .glow-select {
            box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9;
            border-color: #38bdf8 !important;
            background: linear-gradient(135deg, #38bdf8 60%, #0ea5e9 100%) !important;
            color: #fff !important;
            animation: glow-pulse-select 1s infinite alternate;
        }
        @keyframes glow-pulse {
            from { box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15; }
            to   { box-shadow: 0 0 6px 2px #ffe082, 0 0 9px 4px #facc15; }
        }
        @keyframes glow-pulse-select {
            from { box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9; }
            to   { box-shadow: 0 0 6px 2px #38bdf8, 0 0 9px 4px #0ea5e9; }
        }
        @media (max-width: 1024px) {
            .max-w-xs, .max-w-xl, .max-w-5xl, .max-w-7xl {
                max-width: 100vw !important;
            }
        }
        @media (max-width: 500px) {
            .text-4xl {
                font-size: 1.3rem !important;
            }
            .text-lg {
                font-size: 0.9rem !important;
            }
            .w-14, .h-24 {
                width: 3.2rem !important;
                height: 4.2rem !important;
            }
            .poker-card {
                min-height: 4.2rem !important;
                width: 3.2rem !important;
                height: 4.2rem !important;
            }
            .rounded-xl {
                border-radius: 0.5rem !important;
            }
            .p-6, .p-8 {
                padding: 0.5rem !important;
            }
            .px-6, .px-8 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
            }
        }
        /* Responsive rules box */
        .rules-mobile {
            position: static !important;
            top: unset !important;
            right: unset !important;
            z-index: unset !important;
            margin: 2rem auto 2rem auto !important;
            width: 100%;
            max-width: 100vw !important;
            border-radius: 0.75rem !important;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        @media (max-width: 1024px) {
            .rules-mobile {
                max-width: 95vw !important;
            }
        }
        @media (max-width: 768px) {
            .rules-mobile {
                position: static !important;
                margin: 0.5rem 0 1rem 0;
                width: 100%;
                max-width: 100vw !important;
                border-radius: 0.75rem !important;
                z-index: 1 !important;
            }
            .rules-mobile-spacer {
                display: none !important;
            }
        }
        .rules-mobile-placeholder {
            display: none;
        }
        @media (max-width: 768px) {
            .rules-mobile-placeholder {
                display: block;
                height: 0;
                margin: 0;
                padding: 0;
            }
        }
        h1, .game-title {
            font-family: 'Luckiest Guy', cursive, sans-serif;
            letter-spacing: 2px;
            text-shadow: 2px 2px 12px #000, 0 0 12px #ffe082;
            color: #ffe082;
            transition: color 0.2s, transform 0.2s;
        }
        .game-title:hover {
            color: #fffbe7;
            transform: scale(1.04);
        }
        /* Add a simple spinner for loading */
        .spinner {
            border: 4px solid #232946;
            border-top: 4px solid #ffe082;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
        .bg-opacity-80, .bg-opacity-90, .bg-opacity-95 {
            backdrop-filter: blur(2px) saturate(1.2);
        }
        .border-yellow-400 {
            box-shadow: 0 0 16px 2px #ffe08280;
        }
        .flex-col.items-center.mx-2.my-2:hover {
            background: rgba(46,204,113,0.08);
            border-radius: 0.75rem;
            box-shadow: 0 2px 12px 0 #ffe08240;
            transition: background 0.2s, box-shadow 0.2s;
        }
        /* Felt background for card and player hand containers */
        .felt-bg {
            background: url("/static/poker-felt.jpg");
            background-size: 300px 300px;
            background-repeat: repeat;
            background-position: center;
            border-radius: 1rem;
            box-shadow: 0 4px 24px 0 #00000040;
            border: 2px solid #2dd4bf;
            /* Add a subtle green overlay for depth */
            position: relative;
            overflow: hidden;
        }
        .felt-bg:before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(46,204,113,0.08) 0%, rgba(0,0,0,0.12) 100%);
            pointer-events: none;
            z-index: 1;
        }
        .felt-bg > * {
            position: relative;
            z-index: 2;
        }
        /* Optional: add a subtle overlay for contrast */
        .felt-bg-overlay {
            background: rgba(35,41,70,0.85);
            border-radius: 1rem;
        }
        /* Leaderboard improvements */
        table {
            border-radius: 0.75rem;
            overflow: hidden;
        }
        th, td {
            padding: 0.75rem 1rem;
        }
        th {
            background: #232946;
            color: #ffe082;
            font-weight: bold;
            letter-spacing: 1px;
        }
        tr:nth-child(even) {
            background: #232946;
        }
        tr:nth-child(odd) {
            background: #181e2a;
        }
        tr.bg-yellow-300 {
            background: #ffe082 !important;
            color: #232946 !important;
        }
        tr.bg-green-200 {
            background: #bbf7d0 !important;
            color: #232946 !important;
        }
        /* Button improvements */
        button:focus {
            outline: 2px solid #2dd4bf;
            outline-offset: 2px;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .felt-bg {
                padding: 1rem !important;
            }
            .game-title {
                font-size: 2rem !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <noscript>
        <div style="color: #fff; background: #232946; padding: 2rem; border-radius: 1rem; text-align: center;">
            JavaScript is required to run Bombpot Poker.
        </div>
    </noscript>
    <script type="text/javascript">
        // Ensure React and ReactDOM are available
        const { useState, useEffect, useRef } = window.React;

        function Card({ rank, suit, flipped, animate }) {
            const isRed = suit === "♥" || suit === "♦";
            const isBlack = suit === "♠" || suit === "♣";
            const cardRef = useRef(null);

            useEffect(() => {
                if (animate && cardRef.current) {
                    cardRef.current.classList.add('flip-animate');
                    const timeout = setTimeout(() => {
                        cardRef.current.classList.remove('flip-animate');
                    }, 600);
                    return () => clearTimeout(timeout);
                }
            }, [animate]);

            return (
                React.createElement('div', {
                    ref: cardRef,
                    className: `w-14 h-24 rounded-xl flex flex-col justify-between items-end px-2 py-1 poker-card ${isRed ? "red" : ""} ${isBlack ? "black" : ""} ${flipped ? "flipped" : ""} relative`
                },
                    !flipped && [
                        React.createElement('span', { className: "text-lg font-bold", key: "rank" }, rank),
                        React.createElement('span', { className: "text-xl", key: "suit" }, suit)
                    ]
                )
            );
        }

        function PlayerHand({ player, idx }) {
            return React.createElement('div', { className: "flex flex-col items-center mx-2 my-2" },
                React.createElement('span', { className: "mb-2 text-base font-semibold text-yellow-300 drop-shadow" }, `Player ${idx + 1}`),
                React.createElement('div', { className: "overlap-cards" },
                    player.cards.map((card, i) =>
                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit })
                    )
                )
            );
        }

        function Flop({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex, flops, highlightFourth, selectGlow, predictionOptions, canRevealFourth, predictionsLocked, predictionFirst, predictionSecond }) {
            // Show exposed and flipped cards in correct order, with flip animation for the last revealed
            const totalCards = (flop.exposed || []).length + (flop.flipped || []).length;
            const cards = [];
            const isTwoFlop = flops && flops.first_flop && flops.second_flop;
            const thisFlopFlipped = flop.flipped?.length || 0;
            const otherFlopFlipped = isTwoFlop
                ? flops[flopKey === "first_flop" ? "second_flop" : "first_flop"]?.flipped?.length || 0
                : 0;

            for (let i = 0; i < totalCards; i++) {
                if (i < (flop.exposed || []).length) {
                    cards.push(
                        React.createElement(Card, {
                            key: `exposed-${i}`,
                            rank: flop.exposed[i].rank,
                            suit: flop.exposed[i].suit,
                            flipped: false,
                            animate: lastFlippedIndex === i
                        })
                    );
                } else {
                    const flippedIdx = i - (flop.exposed || []).length;
                    let canReveal = false;
                    let extraClass = "";

                    // Only allow reveal if both predictions are made
                    if (predictionFirst && predictionSecond) {
                        // 4th card logic: thisFlopFlipped === 2 && flippedIdx === 0
                        if (thisFlopFlipped === 2 && flippedIdx === 0) {
                            canReveal = true;
                        }
                        // 5th card logic: thisFlopFlipped === 1 && flippedIdx === 0
                        else if (thisFlopFlipped === 1 && flippedIdx === 0) {
                            // Allow reveal if the other flop's 5th card is still unrevealed (flipped.length === 1)
                            // or if this is the only remaining 5th card
                            const otherFlopKey = flopKey === "first_flop" ? "second_flop" : "first_flop";
                            const otherFlopFlippedCount = flops[otherFlopKey]?.flipped?.length || 0;
                            if (otherFlopFlippedCount === 1 || otherFlopFlippedCount === 0) {
                                canReveal = true;
                            }
                        }
                    }

                    // Highlight the 4th card if requested and allowed
                    if (highlightFourth && thisFlopFlipped === 2 && flippedIdx === 0) {
                        extraClass = "reveal-glow";
                    }

                    cards.push(
                        React.createElement('button', {
                            key: `flipped-${flippedIdx}`,
                            className:
                                "w-14 h-24 rounded-xl border-2 flex items-center justify-center font-bold mx-1 shadow-lg transition-all duration-300 " +
                                (canReveal ? (extraClass || "reveal-glow") : "border-gray-400 bg-gray-400 text-gray-200"),
                            onClick: canReveal ? () => onFlip(flopKey, flippedIdx) : undefined,
                            disabled: !canReveal,
                            "aria-label": "Flip card"
                        }, canReveal ? "reveal" : "")
                    );
                }
            }
            // Prediction dropdown options
            const options = predictionOptions || [];
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: `rounded px-2 py-1 custom-select ${selectGlow ? "glow-select" : ""}`,
                        value: prediction,
                        onChange: e => setPrediction(e.target.value),
                        disabled: predictionsLocked
                    },
                        React.createElement('option', { value: "", disabled: true, hidden: true }, "Select Player"),
                        options.length > 0
                            ? options.map(opt =>
                                React.createElement('option', { key: opt, value: opt }, opt)
                            )
                            : Array.from({ length: numPlayers }, (_, i) =>
                                React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                            )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" }, cards)
            );
        }

        function FlopWithAnimation({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex }) {
            // This version is used after a flip, to animate the newly revealed card
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: "rounded px-2 py-1 custom-select",
                        value: prediction,
                        onChange: e => setPrediction(e.target.value)
                    },
                        Array.from({ length: numPlayers }, (_, i) =>
                            React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                        )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" },
                    [
                        ...((flop.exposed || []).map((card, i) =>
                            React.createElement(Card, {
                                key: `exposed-${i}`,
                                rank: card.rank,
                                suit: card.suit,
                                flipped: false,
                                animate: lastFlippedIndex === i
                            })
                        ))
                    ]
                )
            );
        }

        function describeHandType(handType, tiebreakers) {
            // handType: string or array (for two pair, one pair, etc)
            // tiebreakers: array of ranks, e.g. ['8', '2', '6'] or ['7', '10', '8', '6']
            if (Array.isArray(handType) && handType.length === 3) {
                // Two Pair: [highPair, lowPair, kicker]
                return `Two Pairs of ${handType[0]}s and ${handType[1]}s with a ${handType[2]} kicker`;
            }
            if (Array.isArray(handType) && handType.length > 1) {
                // One Pair: [pair, kicker1, kicker2, ...]
                return `Pair of ${handType[0]}s`;
            }
            if (typeof handType === "string") {
                return handType;
            }
            return String(handType);
        }

        function PokerGame() {
            console.log("PokerGame rendering");
            // --- Restore all state hooks before any logic or return ---
            const [players, setPlayers] = useState([]);
            const [firstFlop, setFirstFlop] = useState({ exposed: [], flipped: [] });
            const [secondFlop, setSecondFlop] = useState({ exposed: [], flipped: [] });
            const [numPlayers, setNumPlayers] = useState(2);
            const [difficulty, setDifficulty] = useState("easy");
            const [loading, setLoading] = useState(false);
            const [winner, setWinner] = useState(null);
            const [error, setError] = useState(null);
            const [predictionFirst, setPredictionFirst] = useState("");
            const [predictionSecond, setPredictionSecond] = useState("");
            const [gameStarted, setGameStarted] = useState(false);
            const [skipOptions, setSkipOptions] = useState(false);
            const [correctPredictions, setCorrectPredictions] = useState(() => Number(localStorage.getItem('correctPredictions')) || 0);
            const [totalPredictions, setTotalPredictions] = useState(() => Number(localStorage.getItem('totalPredictions')) || 0);
            const [lastFlippedFirst, setLastFlippedFirst] = useState(null);
            const [lastFlippedSecond, setLastFlippedSecond] = useState(null);
            const [allCardsRevealed, setAllCardsRevealed] = useState(false);
            const [highlightPrediction, setHighlightPrediction] = useState(true);
            const [highlightFourth, setHighlightFourth] = useState(false);
            const [predictionsLocked, setPredictionsLocked] = useState(false);
            const [playerName, setPlayerName] = useState(() => localStorage.getItem('playerName') || "");
            const [leaderboard, setLeaderboard] = useState([]);
            const [leaderboardJustUpdated, setLeaderboardJustUpdated] = useState(false);
            const bottomRef = useRef(null);
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
            const [selectGlowFirst, setSelectGlowFirst] = useState(false);
            const [selectGlowSecond, setSelectGlowSecond] = useState(false);

            // --- FIX: Define isGameOptionsPage before using it ---
            const isGameOptionsPage = window.location.pathname === "/" || window.location.pathname === "/game-options";

            // --- Add the startGame function inside PokerGame ---
            function startGame(skipLeaderboard = false) {
                setLoading(true);
                fetch('/start_game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_players: numPlayers,
                        num_flops: 2
                    })
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error("Failed to start game.");
                    }
                    return res.json();
                })
                .then(data => {
                    // Defensive: check for valid data
                    if (!data.players || !data.first_flop) {
                        setError("Invalid response from server.");
                        setLoading(false);
                        return;
                    }
                    setPlayers(data.players || []);
                    setFirstFlop(data.first_flop || { exposed: [], flipped: [] });
                    setSecondFlop(data.second_flop || { exposed: [], flipped: [] });
                    setGameStarted(true);
                    setSkipOptions(skipLeaderboard);
                    setLoading(false);
                    setWinner(null);
                    setError(null);
                    setPredictionFirst("");
                    setPredictionSecond("");
                    setLastFlippedFirst(null);
                    setLastFlippedSecond(null);
                    setAllCardsRevealed(false);
                    setHighlightPrediction(true);
                    setHighlightFourth(false);
                    setPredictionsLocked(false);
                })
                .catch(err => {
                    setError("Failed to start game.");
                    setLoading(false);
                });
            }

            // --- Add the flipCard function inside PokerGame ---
            function flipCard(flopKey, flippedIdx) {
                // Determine which flop to update
                const flops = {
                    first_flop: { ...firstFlop },
                    second_flop: { ...secondFlop }
                };
                // Defensive: check if the flop and flippedIdx are valid
                if (!flops[flopKey] || !Array.isArray(flops[flopKey].flipped) || flippedIdx >= flops[flopKey].flipped.length) {
                    setError("Invalid flop or card index.");
                    return;
                }
                // Only allow reveal if both predictions are made
                if (!predictionFirst || !predictionSecond) {
                    setError("Both player predictions must be made before revealing cards.");
                    return;
                }
                fetch('/reveal_card', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        flop: flopKey,
                        index: flippedIdx,
                        flops: flops,
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.error) {
                        setError(data.error);
                        return;
                    }
                    if (data.flops) {
                        if (data.flops.first_flop) setFirstFlop(data.flops.first_flop);
                        if (data.flops.second_flop) setSecondFlop(data.flops.second_flop);
                        setError(null);
                    }
                })
                .catch(() => setError("Failed to reveal card."));
            }

            // --- Add canRevealFourth helper ---
            function canRevealFourth(flopKey) {
                // Both flops must have at least 2 exposed + 1 flipped (i.e., 3 exposed, 1 flipped = 4th card available)
                // Only allow revealing the 4th card if both flops have not yet revealed their 4th card
                // For two-flop games, only allow revealing the 4th card if the other flop's 4th card is not already revealed
                if (!firstFlop || !secondFlop) return true;
                const thisFlop = flopKey === "first_flop" ? firstFlop : secondFlop;
                const otherFlop = flopKey === "first_flop" ? secondFlop : firstFlop;
                // If this flop has 2 exposed and 2 flipped, allow revealing the 4th card
                if ((thisFlop.exposed?.length === 3) && (thisFlop.flipped?.length === 2)) {
                    // Only allow if the other flop's flipped is also 2 (i.e., both ready for 4th card)
                    return (otherFlop.flipped?.length === 2);
                }
                // Otherwise, allow by default
                return true;
            }

            // --- Add the revealWinner function inside PokerGame ---
            function revealWinner() {
                setLoading(true);
                fetch('/reveal_winner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        players,
                        first_flop: firstFlop.exposed.concat(firstFlop.flipped || []),
                        second_flop: secondFlop && secondFlop.exposed.concat(secondFlop.flipped || []),
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => res.json())
                .then(data => {
                    setWinner(data);
                    setShowResults(true);
                    setLoading(false);
                    setError(null);

                    // Update accuracy stats
                    let correct = correctPredictions;
                    let total = totalPredictions;
                    if (typeof data.prediction_correct_first === "boolean") {
                        total += 1;
                        if (data.prediction_correct_first) correct += 1;
                    }
                    if (typeof data.prediction_correct_second === "boolean") {
                        total += 1;
                        if (data.prediction_correct_second) correct += 1;
                    }
                    setCorrectPredictions(correct);
                    setTotalPredictions(total);
                    localStorage.setItem('correctPredictions', correct);
                    localStorage.setItem('totalPredictions', total);
                })
                .catch(() => {
                    setError("Failed to reveal winner.");
                    setLoading(false);
                });
            }

            // --- Helper to reset for next round ---
            function resetGame() {
                setGameStarted(false);
                setSkipOptions(false);
                setWinner(null);
                setShowResults(false);
                setPredictionFirst("");
                setPredictionSecond("");
                setPredictionsLocked(false);
                setHighlightFourth(false);
                setHighlightPrediction(true);
                setError(null);
            }

            // --- Add state for showing results ---
            const [showResults, setShowResults] = useState(false);

            // --- Add effect to glow prediction dropdowns until selected ---
            useEffect(() => {
                setSelectGlowFirst(!predictionFirst);
            }, [predictionFirst]);
            useEffect(() => {
                setSelectGlowSecond(!predictionSecond);
            }, [predictionSecond]);

            // --- Add effect to lock predictions after both are made ---
            useEffect(() => {
                if (predictionFirst && predictionSecond) {
                    setPredictionsLocked(true);
                } else {
                    setPredictionsLocked(false);
                }
            }, [predictionFirst, predictionSecond]);

            // --- Add prediction accuracy calculation ---
            const accuracy = totalPredictions > 0 ? Math.round((correctPredictions / totalPredictions) * 100) : 0;

            // --- FIX: Always return a single parent, and use an array for children. Render game options/leaderboard as siblings to rules ---
            return React.createElement(
                'div',
                null,
                // --- Only show banner/logo when NOT in game ---
                (!gameStarted && !skipOptions) && React.createElement('div', {
                    className: "w-full flex flex-col items-center justify-center py-8 mb-4"
                },
                    React.createElement('img', {
                        src: "/static/logo.png",
                        alt: "Bombpot Poker Logo",
                        style: { width: 120, height: 120, marginBottom: 12 },
                        className: "mx-auto drop-shadow-lg"
                    }),
                    React.createElement('h1', {
                        className: "game-title text-4xl md:text-5xl font-extrabold tracking-wider mb-2"
                    }, "Bombpot Poker"),
                    React.createElement('div', {
                        className: "text-yellow-300 text-lg md:text-xl font-semibold tracking-wide mb-2"
                    }, "Texas Hold'em Bombpot Trainer")
                ),
                // Game Options and Leaderboard (show if not started and not skipping options)
                (!gameStarted && !skipOptions) && [
                    React.createElement('div', {
                        id: "game-options",
                        key: "game-options"
                    },
                        React.createElement('div', {
                            className: "flex flex-col md:flex-row gap-10 justify-center w-full max-w-4xl mx-auto mb-8"
                        },
                            React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-90 rounded-xl p-6 shadow-xl" },
                                // --- Player Name Input ---
                                React.createElement('label', { className: "text-white mb-2 text-lg font-semibold" }, "Your Name:"),
                                React.createElement('input', {
                                    className: "rounded px-2 py-1 mb-4 text-base font-semibold bg-[#232946] border border-gray-400 text-white w-48",
                                    type: "text",
                                    value: playerName,
                                    maxLength: 32,
                                    placeholder: "Enter your name",
                                    onChange: e => setPlayerName(e.target.value.replace(/[^a-zA-Z0-9 _-]/g, "")),
                                    autoFocus: true
                                }),
                                React.createElement('label', { className: "text-white mb-2 text-lg font-semibold" }, "Number of Players:"),
                                React.createElement('select', {
                                    className: "rounded px-2 py-1 custom-select mb-4 text-base font-semibold",
                                    value: numPlayers,
                                    onChange: e => setNumPlayers(Number(e.target.value)),
                                    disabled: loading
                                },
                                    [2, 3, 4, 5, 6].map(n =>
                                        React.createElement('option', { key: n, value: n }, n)
                                    )
                                ),
                                React.createElement('label', { className: "text-white mb-2 text-lg font-semibold mt-2" }, "Select Difficulty:"),
                                React.createElement('select', {
                                    className: "rounded px-2 py-1 custom-select mb-4 text-base font-semibold",
                                    value: difficulty,
                                    onChange: e => setDifficulty(e.target.value),
                                    disabled: loading
                                },
                                    ["easy", "difficult"].map(level =>
                                        React.createElement('option', { key: level, value: level }, level.charAt(0).toUpperCase() + level.slice(1))
                                    )
                                ),
                                React.createElement('button', {
                                    className: "poker-chip px-8 py-3 rounded-full text-lg mt-2",
                                    onClick: () => startGame(false),
                                    disabled: loading || !playerName.trim()
                                }, loading ? "Dealing..." : "Start Game")
                            )
                        ),
                        // --- Leaderboard always under game options ---
                        React.createElement('div', { className: "mt-8 mb-8 flex flex-col items-center" },
                            React.createElement('h3', { className: "text-xl font-bold text-yellow-700 mb-2 text-center" }, "Leaderboard (20+ flops)"),
                            leaderboard && (!Array.isArray(leaderboard) || leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).length === 0)
                                ? React.createElement('div', { className: "text-gray-600 text-center" }, "No leaderboard entries yet.")
                                : React.createElement('table', { className: "min-w-full text-sm bg-[#181e2a] bg-opacity-100 rounded-xl overflow-hidden border border-gray-700" },
                                    React.createElement('thead', null,
                                        React.createElement('tr', { className: "bg-[#232946] text-yellow-300" },
                                            React.createElement('th', { className: "px-4 py-2 text-left" }, "Rank"),
                                            React.createElement('th', { className: "px-4 py-2 text-left" }, "Name"),
                                            React.createElement('th', { className: "px-4 py-2 text-left" }, "Accuracy"),
                                            React.createElement('th', { className: "px-4 py-2 text-left" }, "Flops"),
                                            React.createElement('th', { className: "px-4 py-2 text-left" }, "Difficulty")
                                        )
                                    ),
                                    React.createElement('tbody', null,
                                        leaderboard.map((entry, idx) =>
                                            React.createElement('tr', {
                                                key: entry.name + entry.difficulty,
                                                className:
                                                    playerName.trim().toLowerCase() === entry.name.trim().toLowerCase() && entry.difficulty === difficulty
                                                        ? "bg-yellow-300 text-black font-bold"
                                                        : (idx % 2 === 0 ? "bg-[#232946] text-white" : "bg-[#181e2a] text-white")
                                            },
                                                React.createElement('td', { className: "px-4 py-2" }, idx + 1),
                                                React.createElement('td', { className: "px-4 py-2" }, entry.name),
                                                React.createElement('td', { className: "px-4 py-2" },
                                                    `${Math.round((entry.correct / entry.total) * 100)}%`
                                                ),
                                                React.createElement('td', { className: "px-4 py-2" }, entry.total),
                                                React.createElement('td', { className: "px-4 py-2" }, entry.difficulty ? entry.difficulty.charAt(0).toUpperCase() + entry.difficulty.slice(1) : "")
                                            )
                                        )
                                    )
                                )
                        )
                    )
                ],
                // --- Main UI (show only if gameStarted or skipOptions) ---
                (gameStarted || skipOptions) && React.createElement('div', { className: "min-h-screen flex flex-col items-center bg-gradient-to-br from-[#232946] via-[#1a2a3a] to-[#0a101a] py-8" },
                    React.createElement('div', { className: "flex flex-col items-center w-full max-w-5xl" },
                        // --- Felt background for flops ---
                        React.createElement('div', { className: "felt-bg p-4 md:p-8 mb-10 w-full rounded-xl" },
                            React.createElement('div', { className: "flex flex-col md:flex-row gap-10 justify-center" },
                                (firstFlop.exposed.length + (firstFlop.flipped?.length || 0) > 0)
                                    ? React.createElement(Flop, {
                                        flop: firstFlop,
                                        flopKey: "first_flop",
                                        onFlip: flipCard,
                                        prediction: predictionFirst,
                                        setPrediction: setPredictionFirst,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedFirst,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowFirst,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("first_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "First flop will appear here"),
                                (secondFlop && (secondFlop.exposed.length + (secondFlop.flipped?.length || 0) > 0))
                                    ? React.createElement(Flop, {
                                        flop: secondFlop,
                                        flopKey: "second_flop",
                                        onFlip: flipCard,
                                        prediction: predictionSecond,
                                        setPrediction: setPredictionSecond,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedSecond,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowSecond,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("second_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "Second flop will appear here")
                            )
                        ),
                        // --- Felt background for player hands ---
                        React.createElement('div', { className: "felt-bg p-4 md:p-8 mb-10 w-full rounded-xl" },
                            gameStarted && React.createElement('div', {
                                className: "flex flex-wrap justify-center gap-6 w-full"
                            },
                                players.length === 0
                                    ? React.createElement('div', { className: "text-white opacity-60" }, "No players yet. Start a game!")
                                    : players.map((player, idx) =>
                                        React.createElement(PlayerHand, { key: idx, player: player, idx: idx })
                                    )
                            )
                        )
                    ),
                    gameStarted &&
                    predictionFirst && predictionSecond &&
                    !winner &&
                    React.createElement('button', {
                        className: "poker-chip px-8 py-3 rounded-full text-lg mb-6",
                        onClick: () => revealWinner(),
                        style: { minWidth: 180 }
                    }, "Skip to Results"),
                    // --- Show prediction accuracy ---
                    React.createElement('div', { className: "text-yellow-300 font-bold mb-2 text-lg" },
                        "Prediction Accuracy: ",
                        React.createElement('span', { className: "text-white" }, `${accuracy}%`),
                        React.createElement('span', { className: "text-gray-400 text-sm ml-2" }, `(${correctPredictions}/${totalPredictions})`)
                    ),
                    error && React.createElement('div', { className: "bg-red-200 text-red-800 rounded px-4 py-2 mb-4" },
                        typeof error === "string"
                            ? error
                            : "Could not reveal winner. Please try again."
                    ),
                    showResults && winner && React.createElement('div', { className: "bg-white bg-opacity-95 rounded-2xl p-8 shadow-2xl text-black mt-4 max-w-xl w-full border-4 border-yellow-400" },
                        React.createElement('h2', { className: "text-2xl font-bold mb-4 text-yellow-600" }, "Results"),
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "First Flop Winner:"),
                            React.createElement('div', null, winner.winner_first, " (", winner.hand_type_first, ")"),
                            winner.prediction_correct_first !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_first ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_first ? "Your prediction was correct!" : "Your prediction was incorrect.")
                        ),
                        winner.winner_second &&
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "Second Flop Winner:"),
                            React.createElement('div', null, winner.winner_second, " (", winner.hand_type_second, ")"),
                            winner.prediction_correct_second !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_second ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_second ? "Your prediction was correct!" : "Your prediction was incorrect.")
                        ),
                        React.createElement('button', {
                            className: "poker-chip px-8 py-3 rounded-full text-lg mt-4",
                            onClick: resetGame
                        }, "Play Again")
                    )
                ),
                // --- Game Rules at the very bottom, always rendered ---
                React.createElement('div', {
                    className: "rules-mobile bg-[#232946] bg-opacity-95 rounded-xl shadow-xl border-2 border-yellow-400 px-6 py-4 max-w-xs mx-auto mb-8 mt-8"
                },
                    React.createElement('h2', { className: "text-lg font-bold text-yellow-300 mb-2" }, "Game Rules:"),
                    React.createElement('ol', { className: "list-decimal list-inside text-white text-sm space-y-1" },
                        React.createElement('li', null, "Standard Texas Holdum Rules in play."),
                        React.createElement('li', null, "Two cards of players hand MUST play."),
                        React.createElement('li', null, "The same two cards can be used for both hands."),
                        React.createElement('li', null, "The game will reset automatically after 20 flops are reached and your accuracy will be submitted to the leaderboard.")
                    )
                )
            );
        }

        // Attach scrollToGameOptions to window so it can be called from outside React
        window.scrollToGameOptions = function() {
            const el = document.getElementById('game-options');
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };

        // Move all debug logs to the very top of the script
        console.log("Bombpot Poker script loaded");
        console.log("React version:", window.React && window.React.version);
        console.log("ReactDOM version:", window.ReactDOM && window.ReactDOM.version);
        console.log("PokerGame typeof:", typeof PokerGame);

        // --- Fix: Ensure script runs after all functions are defined ---
        // Remove window.addEventListener('DOMContentLoaded', ...) and replace with direct call at end of script

        function renderPokerGame() {
            const rootEl = document.getElementById('root');
            console.log("renderPokerGame: #root exists?", !!rootEl, "innerHTML:", rootEl && rootEl.innerHTML);
            if (!rootEl) {
                console.error("No #root element found!");
                return;
            }
            if (!window.React || !window.ReactDOM) {
                console.error("React or ReactDOM not loaded!");
                rootEl.innerHTML = "<div style='color:red'>React failed to load. Check your CDN links.";
                return;
            }
            if (typeof PokerGame !== "function") {
                console.error("PokerGame is not defined or not a function. typeof PokerGame:", typeof PokerGame);
                rootEl.innerHTML = "<div style='color:red'>PokerGame is not defined. Check your script order.";
                return;
            }
            try {
                if (window.ReactDOM.createRoot) {
                    window.ReactDOM.createRoot(rootEl).render(React.createElement(PokerGame));
                } else {
                    window.ReactDOM.render(React.createElement(PokerGame), rootEl);
                }
                console.log("ReactDOM.render called"); // <-- Add this line
            } catch (e) {
                console.error("React render error:", e);
                rootEl.innerHTML = "<div style='color:red'>React render error: " + e + "</div>";
            }
        }

        // --- Call renderPokerGame directly at the end of the script ---
        renderPokerGame();

    </script>
</body>
</html>