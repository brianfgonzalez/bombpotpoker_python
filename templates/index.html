<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bombpot Poker</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Luckiest+Guy&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', 'Segoe UI', 'Arial', sans-serif;
            background: #1a2a3a;
            background-image: url("/static/casino-felt.jpg");
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            color: #f3f4f6;
        }
        /* Overlap cards in player hand, leftmost card on top */
        .overlap-cards {
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
        }
        .overlap-cards > * {
            margin-right: -1.7rem;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .overlap-cards > *:first-child {
            margin-right: 0;
        }
        /* Style for select dropdown to ensure readable text */
        .custom-select {
            background-color: #232946 !important;
            color: #fff !important;
            border: 1px solid #393e46;
        }
        /* Make all dropdown options white text on dark background */
        .custom-select option, select.custom-select option {
            background-color: #232946 !important;
            color: #fff !important;
        }
        /* Poker chip effect for buttons */
        .poker-chip {
            background: radial-gradient(circle at 60% 40%, #f7c873 0%, #eab308 80%, #b8860b 100%);
            color: #232946;
            border: 2px solid #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            font-weight: bold;
            letter-spacing: 1px;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .poker-chip:hover {
            transform: scale(1.05);
            background: radial-gradient(circle at 60% 40%, #ffe082 0%, #facc15 80%, #b8860b 100%);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        .poker-chip:active {
            transform: scale(0.97);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        /* Card style enhancements */
        .poker-card {
            background: linear-gradient(135deg, #fff 60%, #e2e8f0 100%);
            border: 2px solid #393e46;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            color: #232946;
            transition: transform 0.3s cubic-bezier(.4,2,.2,1), box-shadow 0.2s;
            transform-style: preserve-3d;
            perspective: 600px;
            min-height: 3.5rem; /* Ensure enough height for rank/suit */
            font-weight: bold;
        }
        .poker-card.flip-animate {
            transform: rotateY(180deg);
        }
        /* Remove hover effect for all .poker-card by default */
        /* .poker-card:hover {
            transform: scale(1.08) rotate(-2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 2;
        } */
        /* Only apply hover effect for non-player cards if needed (handled in React) */
        .poker-card.red {
            color: #e3342f;
            border-color: #e3342f;
        }
        .poker-card.black {
            color: #232946;
            border-color: #232946;
        }
        .poker-card.blue {
            color: #2563eb;
            border-color: #2563eb;
        }
        .poker-card.green {
            color: #22c55e;
            border-color: #22c55e;
        }
        .poker-card.flipped {
            background: repeating-linear-gradient(
                135deg,
                #232946,
                #232946 10px,
                #393e46 10px,
                #393e46 20px
            );
            color: transparent;
            border-color: #393e46;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .overlap-cards > * {
                margin-right: -1.5rem;
            }
            .poker-card {
                min-height: 4.5rem !important;
                width: 3.5rem !important;
                height: 4.5rem !important;
            }
            .w-14, .h-24 {
                width: 3.5rem !important;
                height: 4.5rem !important;
            }
            .flex-col.md\:flex-row {
                flex-direction: column !important;
            }
            .gap-10 {
                gap: 1.5rem !important;
            }
            .px-4, .pt-6 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
                padding-top: 0.5rem !important;
            }
            .py-8 {
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
            }
            .mb-4, .mb-10 {
                margin-bottom: 1rem !important;
            }
            .rounded-xl {
                border-radius: 0.75rem !important;
            }
            .text-4xl {
                font-size: 2rem !important;
            }
            .text-lg {
                font-size: 1rem !important;
            }
            .p-6, .p-8 {
                padding: 1rem !important;
            }
            .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
        }
        .reveal-glow {
            box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15;
            border-color: #ffe082 !important;
            background: linear-gradient(135deg, #ffe082 60%, #facc15 100%) !important;
            color: #232946 !important;
            animation: glow-pulse 1s infinite alternate;
        }
        .glow-select {
            box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9;
            border-color: #38bdf8 !important;
            background: linear-gradient(135deg, #38bdf8 60%, #0ea5e9 100%) !important;
            color: #fff !important;
            animation: glow-pulse-select 1s infinite alternate;
        }
        @keyframes glow-pulse {
            from { box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15; }
            to   { box-shadow: 0 0 6px 2px #ffe082, 0 0 9px 4px #facc15; }
        }
        @keyframes glow-pulse-select {
            from { box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9; }
            to   { box-shadow: 0 0 6px 2px #38bdf8, 0 0 9px 4px #0ea5e9; }
        }
        @media (max-width: 1024px) {
            .max-w-xs, .max-w-xl, .max-w-5xl, .max-w-7xl {
                max-width: 100vw !important;
            }
        }
        @media (max-width: 500px) {
            .text-4xl {
                font-size: 1.3rem !important;
            }
            .text-lg {
                font-size: 0.9rem !important;
            }
            .w-14, .h-24 {
                width: 3rem !important;
                height: 4rem !important;
            }
            .poker-card {
                min-height: 4rem !important;
                width: 3rem !important;
                height: 4rem !important;
            }
            .rounded-xl {
                border-radius: 0.5rem !important;
            }
            .p-6, .p-8 {
                padding: 0.5rem !important;
            }
            .px-6, .px-8 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
            }
            .overlap-cards > * {
                margin-right: -1.2rem;
            }
        }
        /* Responsive rules box */
        .rules-mobile {
            position: static !important;
            top: unset !important;
            right: unset !important;
            z-index: unset !important;
            margin: 2rem auto 2rem auto !important;
            width: 100%;
            max-width: 100vw !important;
            border-radius: 0.75rem !important;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        @media (max-width: 1024px) {
            .rules-mobile {
                max-width: 95vw !important;
            }
        }
        @media (max-width: 768px) {
            .rules-mobile {
                position: static !important;
                margin: 0.5rem 0 1rem 0;
                width: 100%;
                max-width: 100vw !important;
                border-radius: 0.75rem !important;
                z-index: 1 !important;
            }
            .rules-mobile-spacer {
                display: none !important;
            }
        }
        .rules-mobile-placeholder {
            display: none;
        }
        @media (max-width: 768px) {
            .rules-mobile-placeholder {
                display: block;
                height: 0;
                margin: 0;
                padding: 0;
            }
        }
        h1, .game-title {
            font-family: 'Luckiest Guy', cursive, sans-serif;
            letter-spacing: 2px;
            text-shadow: 2px 2px 12px #000, 0 0 12px #ffe082;
            color: #ffe082;
            transition: color 0.2s, transform 0.2s;
        }
        .game-title:hover {
            color: #fffbe7;
            transform: scale(1.04);
        }
        /* Add a simple spinner for loading */
        .spinner {
            border: 4px solid #232946;
            border-top: 4px solid #ffe082;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
        .bg-opacity-80, .bg-opacity-90, .bg-opacity-95 {
            backdrop-filter: blur(2px) saturate(1.2);
        }
        .border-yellow-400 {
            box-shadow: 0 0 16px 2px #ffe08280;
        }
        .flex-col.items-center.mx-2.my-2:hover {
            background: rgba(46,204,113,0.08);
            border-radius: 0.75rem;
            box-shadow: 0 2px 12px 0 #ffe08240;
            transition: background 0.2s, box-shadow 0.2s;
        }
        /* Felt background for card and player hand containers */
        .felt-bg {
            background: url("/static/poker-felt.jpg");
            background-size: 300px 300px;
            background-repeat: repeat;
            background-position: center;
            border-radius: 1rem;
            box-shadow: 0 4px 24px 0 #00000040;
            border: 2px solid #2dd4bf;
            /* Add a subtle green overlay for depth */
            position: relative;
            overflow: hidden;
        }
        .felt-bg:before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(46,204,113,0.08) 0%, rgba(0,0,0,0.12) 100%);
            pointer-events: none;
            z-index: 1;
        }
        .felt-bg > * {
            position: relative;
            z-index: 2;
        }
        /* Optional: add a subtle overlay for contrast */
        .felt-bg-overlay {
            background: rgba(35,41,70,0.85);
            border-radius: 1rem;
        }
        /* Leaderboard improvements */
        table {
            border-radius: 0.75rem;
            overflow: hidden;
        }
        th, td {
            padding: 0.75rem 1rem;
        }
        th {
            background: #232946;
            color: #ffe082;
            font-weight: bold;
            letter-spacing: 1px;
        }
        tr:nth-child(even) {
            background: #232946;
        }
        tr:nth-child(odd) {
            background: #181e2a;
        }
        tr.bg-yellow-300 {
            background: #ffe082 !important;
            color: #232946 !important;
        }
        tr.bg-green-200 {
            background: #bbf7d0 !important;
            color: #232946 !important;
        }
        /* Button improvements */
        button:focus {
            outline: 2px solid #2dd4bf;
            outline-offset: 2px;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .felt-bg {
                padding: 1rem !important;
            }
            .game-title {
                font-size: 2rem !important;
            }
        }

        /* Logo enhancements */
        .logo-container {
            position: relative;
            display: inline-block;
        }
        .logo-glow {
            filter: drop-shadow(0 0 20px rgba(255, 224, 130, 0.6)) 
                    drop-shadow(0 0 40px rgba(255, 224, 130, 0.3));
            transition: transform 0.3s ease, filter 0.3s ease;
        }
        .logo-glow:hover {
            transform: scale(1.1) rotate(5deg);
            filter: drop-shadow(0 0 30px rgba(255, 224, 130, 0.8)) 
                    drop-shadow(0 0 60px rgba(255, 224, 130, 0.4));
        }
        .logo-bg {
            position: absolute;
            inset: -10px;
            background: radial-gradient(circle at center, rgba(255, 224, 130, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            animation: pulse-glow 2s ease-in-out infinite;
            z-index: -1;
        }
        @keyframes pulse-glow {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        /* Fallback poker chip logo */
        .poker-chip-logo {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #ffe082 0%, #facc15 50%, #b8860b 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 
                0 4px 16px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.3);
            border: 3px solid #fff;
            margin-right: 16px;
            filter: drop-shadow(0 0 20px rgba(255, 224, 130, 0.6));
            transition: transform 0.3s ease;
        }
        .poker-chip-logo:hover {
            transform: scale(1.1) rotate(5deg);
        }
        .poker-chip-logo::before {
            content: '';
            position: absolute;
            inset: 8px;
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 50%;
        }
        .chip-inner {
            font-family: 'Luckiest Guy', cursive, sans-serif;
            font-size: 24px;
            color: #232946;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-weight: bold;
            letter-spacing: 1px;
        }
        @media (max-width: 768px) {
            .logo-glow,
            .logo-container img.logo-glow {
                width: 140px !important;
                height: 140px !important;
            }
            .poker-chip-logo {
                width: 140px !important;
                height: 140px !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <noscript>
        <div style="color: #fff; background: #232946; padding: 2rem; border-radius: 1rem; text-align: center;">
            JavaScript is required to run Bombpot Poker.
        </div>
    </noscript>
    <script type="text/javascript">
        // Ensure React and ReactDOM are available
        const { useState, useEffect, useRef } = window.React;

        function Card({ rank, suit, flipped, animate, disableHover }) {
            // Color logic: hearts=red, spades=black, diamonds=blue, clubs=green
            const isRed = suit === "♥";
            const isBlack = suit === "♠";
            const isBlue = suit === "♦";
            const isGreen = suit === "♣";
            const cardRef = useRef(null);

            useEffect(() => {
                if (animate && cardRef.current) {
                    cardRef.current.classList.add('flip-animate');
                    const timeout = setTimeout(() => {
                        cardRef.current.classList.remove('flip-animate');
                    }, 600);
                    return () => clearTimeout(timeout);
                }
            }, [animate]);

            // Compose className for color and hover
            let colorClass = "";
            if (isRed) colorClass = "red";
            else if (isBlack) colorClass = "black";
            else if (isBlue) colorClass = "blue";
            else if (isGreen) colorClass = "green";

            // Only add hover effect if disableHover is false
            const hoverClass = disableHover ? "" : "poker-card-hover";

            return (
                React.createElement('div', {
                    ref: cardRef,
                    className: `w-14 h-24 rounded-xl flex flex-col justify-between items-end px-2 py-1 poker-card ${colorClass} ${flipped ? "flipped" : ""} relative ${hoverClass}`
                },
                    !flipped && [
                        React.createElement('span', { className: "text-lg font-bold", key: "rank" }, rank),
                        React.createElement('span', { className: "text-xl", key: "suit" }, suit)
                    ]
                )
            );
        }

        function PlayerHand({ player, idx, winningPlayers }) {
            // Sort cards by suit first, then by rank from lowest to highest
            const suitOrder = ['♣', '♦', '♥', '♠']; // Clubs, Diamonds, Hearts, Spades
            const rankOrder = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            
            const sortedCards = [...player.cards].sort((a, b) => {
                // First sort by suit
                const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
                if (suitDiff !== 0) return suitDiff;
                // Then sort by rank (lowest to highest)
                return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank);
            });
            
            // Check if this player is winning any flop
            const playerName = `Player ${idx + 1}`;
            
            // Handle both string and array winners
            const isWinningFirst = Array.isArray(winningPlayers?.first) 
                ? winningPlayers.first.includes(playerName)
                : winningPlayers?.first === playerName;
            const isWinningSecond = Array.isArray(winningPlayers?.second)
                ? winningPlayers.second.includes(playerName)
                : winningPlayers?.second === playerName;
            
            // Create separate container classes for each flop
            let containerClass = "flex flex-col items-center mx-0 md:mx-1 my-1 md:my-2 p-1 md:p-2 rounded-lg transition-all duration-300 relative";
            
            // Add visual indicators for each flop separately
            const indicators = [];
            if (isWinningFirst) {
                indicators.push(React.createElement('div', { 
                    key: 'first-indicator',
                    className: "absolute -top-2 -left-2 bg-yellow-400 text-black rounded-full w-6 h-6 md:w-8 md:h-8 flex items-center justify-center font-bold text-xs shadow-lg z-10"
                }, "1st"));
            }
            if (isWinningSecond) {
                indicators.push(React.createElement('div', { 
                    key: 'second-indicator',
                    className: "absolute -top-2 -right-2 bg-blue-400 text-black rounded-full w-6 h-6 md:w-8 md:h-8 flex items-center justify-center font-bold text-xs shadow-lg z-10"
                }, "2nd"));
            }
            
            // Apply different styling based on which flop(s) they're winning
            if (isWinningFirst && isWinningSecond) {
                containerClass += " ring-2 md:ring-4 ring-purple-400 bg-gradient-to-br from-yellow-400 to-blue-400 bg-opacity-20";
            } else if (isWinningFirst) {
                containerClass += " ring-2 md:ring-4 ring-yellow-400 bg-yellow-400 bg-opacity-10";
            } else if (isWinningSecond) {
                containerClass += " ring-2 md:ring-4 ring-blue-400 bg-blue-400 bg-opacity-10";
            }
            
            return React.createElement('div', { className: containerClass },
                ...indicators,
                React.createElement('span', { 
                    className: `mb-1 md:mb-2 text-sm md:text-base font-semibold drop-shadow ${isWinningFirst || isWinningSecond ? 'text-white' : 'text-yellow-300'}` 
                }, 
                    playerName,
                    isWinningFirst && isWinningSecond && React.createElement('span', { className: "ml-1 md:ml-2 text-xs" }, "🏆 Both"),
                    isWinningFirst && !isWinningSecond && React.createElement('span', { className: "ml-1 md:ml-2 text-xs text-yellow-400" }, "🏆"),
                    !isWinningFirst && isWinningSecond && React.createElement('span', { className: "ml-1 md:ml-2 text-xs text-blue-400" }, "🏆")
                ),
                React.createElement('div', { className: "overlap-cards" },
                    sortedCards.map((card, i) =>
                        // Pass disableHover=true for player cards
                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit, disableHover: true })
                    )
                )
            );
        }

        function Flop({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex, flops, highlightFourth, selectGlow, predictionOptions, canRevealFourth, predictionsLocked, predictionFirst, predictionSecond, difficulty }) {
            // Show exposed and flipped cards in correct order, with flip animation for the last revealed
            const totalCards = (flop.exposed || []).length + (flop.flipped || []).length;
            const cards = [];
            const isTwoFlop = flops && flops.first_flop && flops.second_flop;
            const thisFlopFlipped = flop.flipped?.length || 0;
            const otherFlopFlipped = isTwoFlop
                ? flops[flopKey === "first_flop" ? "second_flop" : "first_flop"]?.flipped?.length || 0
                : 0;

            for (let i = 0; i < totalCards; i++) {
                if (i < (flop.exposed || []).length) {
                    cards.push(
                        React.createElement(Card, {
                            key: `exposed-${i}`,
                            rank: flop.exposed[i].rank,
                            suit: flop.exposed[i].suit,
                            flipped: false,
                            animate: lastFlippedIndex === i
                        })
                    );
                } else {
                    const flippedIdx = i - (flop.exposed || []).length;
                    let canReveal = false;
                    let extraClass = "";

                    // Only allow reveal if both predictions are made
                    if (predictionFirst && predictionSecond) {
                        // 4th card logic: thisFlopFlipped === 2 && flippedIdx === 0
                        if (thisFlopFlipped === 2 && flippedIdx === 0) {
                            canReveal = true;
                        }
                        // 5th card logic: thisFlopFlipped === 1 && flippedIdx === 0
                        else if (thisFlopFlipped === 1 && flippedIdx === 0) {
                            // Allow reveal if the other flop's 5th card is still unrevealed (flipped.length === 1)
                            // or if this is the only remaining 5th card
                            const otherFlopKey = flopKey === "first_flop" ? "second_flop" : "first_flop";
                            const otherFlopFlippedCount = flops[otherFlopKey]?.flipped?.length || 0;
                            if (otherFlopFlippedCount === 1 || otherFlopFlippedCount === 0) {
                                canReveal = true;
                            }
                        }
                    }

                    // Highlight the 4th card if requested and allowed
                    if (highlightFourth && thisFlopFlipped === 2 && flippedIdx === 0) {
                        extraClass = "reveal-glow";
                    }

                    cards.push(
                        React.createElement('button', {
                            key: `flipped-${flippedIdx}`,
                            className:
                                "w-14 h-24 rounded-xl border-2 flex items-center justify-center font-bold mx-1 shadow-lg transition-all duration-300 " +
                                (canReveal ? (extraClass || "reveal-glow") : "border-gray-400 bg-gray-400 text-gray-200"),
                            onClick: canReveal ? () => onFlip(flopKey, flippedIdx) : undefined,
                            disabled: !canReveal,
                            "aria-label": "Flip card"
                        }, canReveal ? "reveal" : "")
                    );
                }
            }
            // Prediction dropdown options
            const options = predictionOptions || [];
            const labelText = difficulty === "easy" ? "Winner:" : "Prediction:";
            
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, labelText),
                    React.createElement('select', {
                        className: `rounded px-2 py-1 custom-select ${selectGlow ? "glow-select" : ""}`,
                        value: prediction,
                        onChange: e => setPrediction(e.target.value),
                        disabled: predictionsLocked
                    },
                        React.createElement('option', { value: "", disabled: true, hidden: true }, "Select Player"),
                        options.length > 0
                            ? options.map(opt =>
                                React.createElement('option', { key: opt, value: opt }, opt)
                            )
                            : Array.from({ length: numPlayers }, (_, i) =>
                                React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                            )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" }, cards)
            );
        }

        function FlopWithAnimation({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex }) {
            // This version is used after a flip, to animate the newly revealed card
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: "rounded px-2 py-1 custom-select",
                        value: prediction,
                        onChange: e => setPrediction(e.target.value)
                    },
                        Array.from({ length: numPlayers }, (_, i) =>
                            React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                        )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" },
                    [
                        ...((flop.exposed || []).map((card, i) =>
                            React.createElement(Card, {
                                key: `exposed-${i}`,
                                rank: card.rank,
                                suit: card.suit,
                                flipped: false,
                                animate: lastFlippedIndex === i
                            })
                        ))
                    ]
                )
            );
        }

        function describeHandType(handType, tiebreakers) {
            // Helper to add 's' to rank for pluralization
            function pluralRank(rank) {
                if (rank === "6") return "6s";
                if (rank === "7") return "7s";
                if (rank === "8") return "8s";
                if (rank === "9") return "9s";
                if (rank === "10") return "Tens";
                if (rank === "J") return "Js";
                if (rank === "Q") return "Qs";
                if (rank === "K") return "Ks";
                if (rank === "A") return "As";
                return rank + "s";
            }

            // Helper to convert rank to readable format
            function rankToWord(rank) {
                if (rank === "10") return "Ten";
                if (rank === "J") return "Jack";
                if (rank === "Q") return "Queen";
                if (rank === "K") return "King";
                if (rank === "A") return "Ace";
                return rank;
            }

            if (Array.isArray(handType) && handType.length === 3) {
                // Two Pair: [highPair, lowPair, kicker]
                return `Two Pairs ${pluralRank(handType[0])} and ${pluralRank(handType[1])}`;
            }
            if (Array.isArray(handType) && handType.length > 1) {
                // One Pair: [pair, kicker1, kicker2, ...]
                return `Pair of ${pluralRank(handType[0])}`;
            }
            // Check if it's a straight with high card info
            if (typeof handType === "string" && handType.startsWith("Straight")) {
                // Extract high card if provided (e.g., "Straight K" or "Straight, K high")
                const match = handType.match(/Straight[,\s]+([2-9JQKA]|10)/i);
                if (match && match[1]) {
                    return `${rankToWord(match[1])}-high Straight`;
                }
                return "Straight";
            }
            // Check if it's a flush with high card info
            if (typeof handType === "string" && handType.includes("-high Flush")) {
                // Already formatted correctly from backend
                return handType;
            }
            if (typeof handType === "string") {
                return handType;
            }
            return String(handType);
        }

        function PokerGame() {
            console.log("PokerGame rendering");
            // --- Restore all state hooks before any logic or return ---
            const [players, setPlayers] = useState([]);
            const [firstFlop, setFirstFlop] = useState({ exposed: [], flipped: [] });
            const [secondFlop, setSecondFlop] = useState({ exposed: [], flipped: [] });
            const [numPlayers, setNumPlayers] = useState(4);  // Changed from 2 to 4
            const [difficulty, setDifficulty] = useState("easy");
            const [loading, setLoading] = useState(false);
            const [winner, setWinner] = useState(null);
            const [error, setError] = useState(null);
            const [predictionFirst, setPredictionFirst] = useState("");
            const [predictionSecond, setPredictionSecond] = useState("");
            const [gameStarted, setGameStarted] = useState(false);
            const [skipOptions, setSkipOptions] = useState(false);
            const [correctPredictions, setCorrectPredictions] = useState(() => Number(localStorage.getItem('correctPredictions')) || 0);
            const [totalPredictions, setTotalPredictions] = useState(() => Number(localStorage.getItem('totalPredictions')) || 0);
            const [lastFlippedFirst, setLastFlippedFirst] = useState(null);
            const [lastFlippedSecond, setLastFlippedSecond] = useState(null);
            const [allCardsRevealed, setAllCardsRevealed] = useState(false);
            const [highlightPrediction, setHighlightPrediction] = useState(true);
            const [highlightFourth, setHighlightFourth] = useState(false);
            const [predictionsLocked, setPredictionsLocked] = useState(false);
            const [playerName, setPlayerName] = useState(() => localStorage.getItem('playerName') || "");
            const [nameHistory, setNameHistory] = useState(() => {
                const saved = localStorage.getItem('nameHistory');
                return saved ? JSON.parse(saved) : [];
            });
            const [leaderboard, setLeaderboard] = useState([]);
            const [leaderboardJustUpdated, setLeaderboardJustUpdated] = useState(false);
            const bottomRef = useRef(null);
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
            const [selectGlowFirst, setSelectGlowFirst] = useState(false);
            const [selectGlowSecond, setSelectGlowSecond] = useState(false);
            const [currentWinners, setCurrentWinners] = useState({ first: null, second: null });
            const [showResults, setShowResults] = useState(false);

            // --- FIX: Define isGameOptionsPage before using it ---
            const isGameOptionsPage = window.location.pathname === "/" || window.location.pathname === "/game-options";

            // Save player name to history when starting a game
            function saveNameToHistory(name) {
                if (!name.trim()) return;
                
                let history = [...nameHistory];
                // Remove if already exists
                history = history.filter(n => n.toLowerCase() !== name.toLowerCase());
                // Add to beginning
                history.unshift(name);
                // Keep only last 10
                history = history.slice(0, 10);
                
                setNameHistory(history);
                localStorage.setItem('nameHistory', JSON.stringify(history));
                localStorage.setItem('playerName', name);
            }

            // Add function to check current winners
            function updateCurrentWinners() {
                if (!gameStarted || players.length === 0) {
                    setCurrentWinners({ first: null, second: null });
                    return;
                }

                // Only calculate if predictions are made
                if (!predictionFirst || !predictionSecond) {
                    setCurrentWinners({ first: null, second: null });
                    return;
                }

                // Only use exposed cards (not flipped)
                const firstFlopCards = firstFlop.exposed?.length || 0;
                const secondFlopCards = secondFlop.exposed?.length || 0;

                // In difficult mode, don't show winners until cards are actually revealed
                if (difficulty === "difficult" && firstFlopCards <= 3 && secondFlopCards <= 3) {
                    setCurrentWinners({ first: null, second: null });
                    return;
                }

                // In easy mode with all cards shown, show predicted winners immediately
                if (difficulty === "easy" && firstFlopCards >= 5 && secondFlopCards >= 5) {
                    setCurrentWinners({
                        first: predictionFirst,
                        second: predictionSecond
                    });
                    return;
                }

                // When we have 4 or 5 exposed cards, calculate actual winners
                if (firstFlopCards >= 4 || secondFlopCards >= 4) {
                    // Make API call to determine current winners based on exposed cards only
                    fetch('/reveal_winner', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            players,
                            first_flop: firstFlopCards >= 3 ? firstFlop.exposed : [],
                            second_flop: secondFlopCards >= 3 ? secondFlop.exposed : [],
                            prediction_first: predictionFirst || "temp",
                            prediction_second: predictionSecond || "temp"
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        // Update winners based on current exposed cards
                        const newWinners = {
                            first: firstFlopCards >= 4 ? data.winner_first : predictionFirst,
                            second: secondFlopCards >= 4 ? data.winner_second : predictionSecond
                        };
                        
                        // Always update to show actual winners when cards are revealed
                        setCurrentWinners(newWinners);
                        console.log("Winners updated after API call:", newWinners);
                    })
                    .catch((err) => {
                        console.error("Error updating winners:", err);
                        // On error, keep predictions as winners
                        setCurrentWinners({
                            first: predictionFirst,
                            second: predictionSecond
                        });
                    });
                }
            }

            // Update winners when cards are revealed
            useEffect(() => {
                if (gameStarted && !showResults) {
                    // Only update if we have exposed cards beyond the initial 3
                    const firstFlopCards = firstFlop.exposed?.length || 0;
                    const secondFlopCards = secondFlop.exposed?.length || 0;
                    
                    if (firstFlopCards > 3 || secondFlopCards > 3) {
                        updateCurrentWinners();
                    }
                }
            }, [firstFlop.exposed?.length, secondFlop.exposed?.length, gameStarted, showResults]);

            // --- Add the startGame function inside PokerGame ---
            function startGame(skipLeaderboard = false) {
                // Save name to history
                if (playerName.trim()) {
                    saveNameToHistory(playerName.trim());
                }

                // Check if we've reached 20 flops and need to submit to leaderboard
                if (totalPredictions >= 20 && playerName.trim()) {
                    // Submit to leaderboard
                    fetch('/update_leaderboard', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: playerName.trim(),
                            correct: correctPredictions,
                            total: totalPredictions,
                            difficulty: difficulty
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            // Reset stats after submitting
                            setCorrectPredictions(0);
                            setTotalPredictions(0);
                            localStorage.setItem('correctPredictions', 0);
                            localStorage.setItem('totalPredictions', 0);
                            // Refresh leaderboard
                            fetch('/leaderboard')
                                .then(res => res.json())
                                .then(data => {
                                    setLeaderboard(data.leaderboard || []);
                                });
                        }
                    })
                    .catch(err => console.error("Failed to update leaderboard:", err));
                }

                setLoading(true);
                fetch('/start_game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_players: numPlayers,
                        num_flops: 2,
                        difficulty: difficulty  // Pass difficulty to backend
                    })
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error("Failed to start game.");
                    }
                    return res.json();
                })
                .then(data => {
                    // Defensive: check for valid data
                    if (!data.players || !data.first_flop) {
                        setError("Invalid response from server.");
                        setLoading(false);
                        return;
                    }
                    setPlayers(data.players || []);
                    
                    // For easy mode, all cards are exposed immediately
                    if (difficulty === "easy") {
                        setFirstFlop({ 
                            exposed: [...data.first_flop.exposed, ...data.first_flop.flipped], 
                            flipped: [] 
                        });
                        setSecondFlop({ 
                            exposed: [...data.second_flop.exposed, ...data.second_flop.flipped], 
                            flipped: [] 
                        });
                    } else {
                        // Difficult mode - traditional setup
                        setFirstFlop(data.first_flop || { exposed: [], flipped: [] });
                        setSecondFlop(data.second_flop || { exposed: [], flipped: [] });
                    }
                    
                    setGameStarted(true);
                    setSkipOptions(skipLeaderboard);
                    setLoading(false);
                    setWinner(null);
                    setError(null);
                    setPredictionFirst("");
                    setPredictionSecond("");
                    setLastFlippedFirst(null);
                    setLastFlippedSecond(null);
                    setAllCardsRevealed(difficulty === "easy"); // Easy mode starts with all cards revealed
                    setHighlightPrediction(true);
                    setHighlightFourth(false);
                    setPredictionsLocked(false);
                })
                .catch(err => {
                    setError("Failed to start game.");
                    setLoading(false);
                });
            }

            // --- Add resetPredictionAccuracy function ---
            function resetPredictionAccuracy() {
                if (confirm("Are you sure you want to reset your prediction accuracy? This will clear all your stats.")) {
                    setCorrectPredictions(0);
                    setTotalPredictions(0);
                    localStorage.setItem('correctPredictions', 0);
                    localStorage.setItem('totalPredictions', 0);
                }
            }

            // --- Add the flipCard function inside PokerGame ---
            function flipCard(flopKey, flippedIdx) {
                // Determine which flop to update
                const flops = {
                    first_flop: { ...firstFlop },
                    second_flop: { ...secondFlop }
                };
                // Defensive: check if the flop and flippedIdx are valid
                if (!flops[flopKey] || !Array.isArray(flops[flopKey].flipped) || flippedIdx >= flops[flopKey].flipped.length) {
                    setError("Invalid flop or card index.");
                    return;
                }
                // Only allow reveal if both predictions are made
                if (!predictionFirst || !predictionSecond) {
                    setError("Both player predictions must be made before revealing cards.");
                    return;
                }
                fetch('/reveal_card', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        flop: flopKey,
                        index: flippedIdx,
                        flops: flops,
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.error) {
                        setError(data.error);
                        return;
                    }
                    if (data.flops) {
                        if (data.flops.first_flop) setFirstFlop(data.flops.first_flop);
                        if (data.flops.second_flop) setSecondFlop(data.flops.second_flop);
                        setError(null);
                        
                        // Don't call updateCurrentWinners here - let the useEffect handle it
                        // This prevents race conditions
                    }
                })
                .catch(() => setError("Failed to reveal card."));
            }

            // --- Add canRevealFourth helper ---
            function canRevealFourth(flopKey) {
                // Both flops must have at least 2 exposed + 1 flipped (i.e., 3 exposed, 1 flipped = 4th card available)
                // Only allow revealing the 4th card if both flops have not yet revealed their 4th card
                // For two-flop games, only allow revealing the 4th card if the other flop's 4th card is not already revealed
                if (!firstFlop || !secondFlop) return true;
                const thisFlop = flopKey === "first_flop" ? firstFlop : secondFlop;
                const otherFlop = flopKey === "first_flop" ? secondFlop : firstFlop;
                // If this flop has 2 exposed and 2 flipped, allow revealing the 4th card
                if ((thisFlop.exposed?.length === 3) && (thisFlop.flipped?.length === 2)) {
                    // Only allow if the other flop's flipped is also 2 (i.e., both ready for 4th card)
                    return (otherFlop.flipped?.length === 2);
                }
                // Otherwise, allow by default
                return true;
            }

            // --- Add the revealWinner function inside PokerGame ---
            function revealWinner() {
                // Don't proceed if already loading or if we don't have predictions
                if (loading || !predictionFirst || !predictionSecond) {
                    console.error("Cannot reveal winner: loading =", loading, "predictions =", predictionFirst, predictionSecond);
                    return;
                }
                
                setLoading(true);
                
                // Prepare the flop data without modifying state yet
                const firstFlopData = [...firstFlop.exposed];
                const secondFlopData = [...secondFlop.exposed];
                
                // Add any remaining flipped cards to the data
                if (firstFlop.flipped && firstFlop.flipped.length > 0) {
                    firstFlopData.push(...firstFlop.flipped);
                }
                if (secondFlop.flipped && secondFlop.flipped.length > 0) {
                    secondFlopData.push(...secondFlop.flipped);
                }
                
                // Debug logging
                console.log("Revealing winner with data:", {
                    players: players,
                    first_flop: firstFlopData,
                    second_flop: secondFlopData,
                    prediction_first: predictionFirst,
                    prediction_second: predictionSecond
                });
                
                fetch('/reveal_winner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        players: players,
                        first_flop: firstFlopData,
                        second_flop: secondFlopData,
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    return res.json();
                })
                .then(data => {
                    // Update current winners FIRST with the final results
                    setCurrentWinners({
                        first: data.winner_first,
                        second: data.winner_second
                    });
                    
                    // Now update the state to show all cards revealed
                    const allFlops = {
                        first_flop: { exposed: firstFlopData, flipped: [] },
                        second_flop: { exposed: secondFlopData, flipped: [] }
                    };
                    
                    // Use setTimeout to ensure currentWinners state is updated before updating flops
                    setTimeout(() => {
                        setFirstFlop(allFlops.first_flop);
                        setSecondFlop(allFlops.second_flop);
                        setWinner(data);
                        setShowResults(true);
                        setLoading(false);
                        setError(null);
                        
                        // Update prediction statistics
                        const correctCount = (data.prediction_correct_first ? 1 : 0) + 
                                           (data.prediction_correct_second ? 1 : 0);
                        const newCorrect = correctPredictions + correctCount;
                        const newTotal = totalPredictions + 2;
                        
                        setCorrectPredictions(newCorrect);
                        setTotalPredictions(newTotal);
                        localStorage.setItem('correctPredictions', newCorrect);
                        localStorage.setItem('totalPredictions', newTotal);

                        // Auto-scroll to results after a short delay to ensure DOM is updated
                        setTimeout(() => {
                            const resultsElement = document.getElementById('game-results');
                            if (resultsElement) {
                                // Try multiple scroll methods for better compatibility
                                resultsElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                
                                // Fallback: calculate position and scroll manually
                                const yOffset = -100; // Adjust this value to fine-tune scroll position
                                const y = resultsElement.getBoundingClientRect().top + window.pageYOffset + yOffset;
                                window.scrollTo({ top: y, behavior: 'smooth' });
                            }
                        }, 300); // Increased delay to ensure React has rendered
                    }, 50); // Small delay to ensure state update happens in correct order
                })
                .catch(err => {
                    console.error("Error revealing winner:", err);
                    console.error("Error details:", err.message);
                    setLoading(false);
                    setError(`Failed to reveal winner: ${err.message || 'Unknown error'}`);
                });
            }

            // --- Helper to reset for next round ---
            function resetGame() {
                setWinner(null);
                setShowResults(false);
                setPredictionFirst("");
                setPredictionSecond("");
                setPredictionsLocked(false);
                setHighlightFourth(false);
                setHighlightPrediction(true);
                setError(null);
                setAllCardsRevealed(false);
                setCurrentWinners({ first: null, second: null });
                
                // Scroll to top before starting new game
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // Small delay to ensure scroll completes before game starts
                setTimeout(() => {
                    startGame(true); // Automatically start new game with same options
                }, 300);
            }

            // --- Add goToGameOptions function here ---
            function goToGameOptions() {
                setGameStarted(false);
                setSkipOptions(false);
                setWinner(null);
                setShowResults(false);
                setPredictionFirst("");
                setPredictionSecond("");
                setPredictionsLocked(false);
                setHighlightFourth(false);
                setHighlightPrediction(true);
                setError(null);
                setAllCardsRevealed(false);
                
                // Scroll to top when going to game options
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }

            // --- Add effect to glow prediction dropdowns until selected ---
            useEffect(() => {
                setSelectGlowFirst(!predictionFirst);
            }, [predictionFirst]);
            useEffect(() => {
                setSelectGlowSecond(!predictionSecond);
            }, [predictionSecond]);

            // --- Add effect to lock predictions after both are made ---
            useEffect(() => {
                if (predictionFirst && predictionSecond) {
                    setPredictionsLocked(true);
                    // Only show predicted winners if in easy mode (all cards visible)
                    // In difficult mode, don't show any winners until cards are revealed
                    if (difficulty === "easy") {
                        setCurrentWinners({
                            first: predictionFirst,
                            second: predictionSecond
                        });
                    }
                } else {
                    setPredictionsLocked(false);
                }
            }, [predictionFirst, predictionSecond, difficulty]);

            // Add effect to fetch leaderboard on component mount
            useEffect(() => {
                fetch('/leaderboard')
                    .then(res => res.json())
                    .then(data => {
                        setLeaderboard(data.leaderboard || []);
                    })
                    .catch(err => console.error("Failed to fetch leaderboard:", err));
            }, []);

            // Add effect to fetch leaderboard when difficulty changes
            useEffect(() => {
                fetch(`/leaderboard?difficulty=${difficulty}`)
                    .then(res => res.json())
                    .then(data => {
                        setLeaderboard(data.leaderboard || []);
                    })
                    .catch(err => console.error("Failed to fetch leaderboard:", err));
            }, [difficulty]);

            // Update allCardsRevealed state when both flops have no flipped cards left
            useEffect(() => {
                if (
                    gameStarted &&
                    firstFlop.flipped.length === 0 &&
                    secondFlop.flipped.length === 0 &&
                    !allCardsRevealed
                ) {
                    setAllCardsRevealed(true);
                }
            }, [firstFlop.flipped, secondFlop.flipped, gameStarted]);

            // Trigger revealWinner when allCardsRevealed becomes true
            useEffect(() => {
                if (allCardsRevealed && !showResults && !winner && predictionFirst && predictionSecond && !loading) {
                    revealWinner();
                }
            }, [allCardsRevealed, showResults, winner, predictionFirst, predictionSecond, loading]);

            // --- Add prediction accuracy calculation ---
            const accuracy = totalPredictions > 0 ? Math.round((correctPredictions / totalPredictions) * 100) : 0;

            // --- FIX: Always return a single parent, and use an array for children. Render game options/leaderboard as siblings to rules ---
            return React.createElement(
                'div',
                null,
                // --- Show banner/logo always with game options on the right ---
                React.createElement('div', {
                    className: "w-full flex flex-col md:flex-row items-center justify-between py-4 mb-4 px-4 bg-[#232946] bg-opacity-90"
                },
                    // Left side: Logo and title
                    React.createElement('div', {
                        className: "flex flex-col md:flex-row items-center"
                    },
                        // Only show logo on desktop, or on mobile when game not started
                        (!gameStarted || !isMobile) && React.createElement('a', {
                            href: "/",
                            onClick: (e) => {
                                e.preventDefault();
                                goToGameOptions();
                            },
                            className: "cursor-pointer logo-container"
                        },
                            React.createElement('div', { className: "logo-bg" }),
                            React.createElement('img', {
                                src: "/static/logo.png",
                                alt: "Bombpot Poker Logo",
                                style: { 
                                    width: 80, 
                                    height: 80,
                                    backgroundColor: 'transparent' // Ensure transparent background
                                },
                                className: "logo-glow relative z-10",
                                onError: (e) => {
                                    // If logo fails to load, show a stylized chip icon
                                    e.target.style.display = 'none';
                                    e.target.parentElement.innerHTML = `
                                        <div class="poker-chip-logo">
                                            <div class="chip-inner">BP</div>
                                        </div>
                                    `;
                                }
                            })
                        ),
                        // Only show title on desktop, or on mobile when game not started
                        (!gameStarted || !isMobile) && React.createElement('a', {
                            href: "/",
                            onClick: (e) => {
                                e.preventDefault();
                                goToGameOptions();
                            },
                            className: "cursor-pointer no-underline"
                        },
                            React.createElement('div', { className: "text-center md:text-left" },
                                React.createElement('h1', {
                                    className: "game-title text-2xl md:text-3xl font-extrabold tracking-wider"
                                }, "Bombpot Poker"),
                                React.createElement('div', {
                                    className: "text-yellow-300 text-sm md:text-base font-semibold tracking-wide"
                                }, "Texas Hold'em Bombpot Trainer")
                            )
                        )
                    ),
                    // Add a "Menu" button on mobile when game is started
                    (gameStarted && isMobile) && React.createElement('button', {
                        className: "poker-chip px-4 py-2 rounded-full text-sm",
                        onClick: goToGameOptions
                    }, "Menu"),
                    // Right side: Game options (only show if not in game)
                    (!gameStarted && !skipOptions) && React.createElement('div', {
                        className: "flex flex-col md:flex-row items-center gap-2 mt-4 md:mt-0"
                    },
                        React.createElement('div', { className: "relative" },
                            React.createElement('input', {
                                className: "rounded px-2 py-1 text-sm font-semibold bg-[#232946] border border-gray-400 text-white w-32",
                                type: "text",
                                value: playerName,
                                maxLength: 32,
                                placeholder: "Your name",
                                onChange: e => setPlayerName(e.target.value.replace(/[^a-zA-Z0-9 _-]/g, "")),
                                autoFocus: true,
                                list: "name-history"
                            }),
                            React.createElement('datalist', { id: "name-history" },
                                nameHistory.map(name => 
                                    React.createElement('option', { key: name, value: name })
                                )
                            )
                        ),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select text-sm font-semibold",
                            value: numPlayers,
                            onChange: e => setNumPlayers(Number(e.target.value)),
                            disabled: loading
                        },
                            [2, 3, 4, 5, 6].map(n =>
                                React.createElement('option', { key: n, value: n }, `${n} Players`)
                            )
                        ),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select text-sm font-semibold",
                            value: difficulty,
                            onChange: e => setDifficulty(e.target.value),
                            disabled: loading
                        },
                            ["easy", "difficult"].map(level =>
                                React.createElement('option', { key: level, value: level }, level.charAt(0).toUpperCase() + level.slice(1))
                            )
                        ),
                        React.createElement('button', {
                            className: "poker-chip px-6 py-2 rounded-full text-sm",
                            onClick: () => startGame(false),
                            disabled: loading || !playerName.trim()
                        }, loading ? "Dealing..." : "Start Game")
                    )
                ),
                // Leaderboard (show if not started and not skipping options)
                (!gameStarted && !skipOptions) && React.createElement('div', { className: "mb-8 flex flex-col items-center" },
                    React.createElement('h3', { className: "text-xl font-bold text-yellow-700 mb-2 text-center" }, 
                        `${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} Mode Leaderboard (20+ flops)`
                    ),
                    leaderboard && (!Array.isArray(leaderboard) || leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).length === 0)
                        ? React.createElement('div', { className: "text-gray-600 text-center" }, "No leaderboard entries yet.")
                        : React.createElement('table', { className: "min-w-full text-sm bg-[#181e2a] bg-opacity-100 rounded-xl overflow-hidden border border-gray-700" },
                            React.createElement('thead', null,
                                React.createElement('tr', { className: "bg-[#232946] text-yellow-300" },
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Rank"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Name"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Accuracy"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Flops"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Difficulty")
                                )
                            ),
                            React.createElement('tbody', null,
                                leaderboard.map((entry, idx) =>
                                    React.createElement('tr', {
                                        key: `${entry.name}-${entry.difficulty}-${idx}`, // Add index to make key unique
                                        className:
                                            playerName.trim().toLowerCase() === entry.name.trim().toLowerCase() && entry.difficulty === difficulty
                                                ? "bg-yellow-300 text-black font-bold"
                                                : (idx % 2 === 0 ? "bg-[#232946] text-white" : "bg-[#181e2a] text-white")
                                    },
                                        React.createElement('td', { className: "px-4 py-2" }, idx + 1),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.name),
                                        React.createElement('td', { className: "px-4 py-2" },
                                            `${Math.round((entry.correct / entry.total) * 100)}%`
                                        ),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.total),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.difficulty ? entry.difficulty.charAt(0).toUpperCase() + entry.difficulty.slice(1) : "")
                                    )
                                )
                            )
                        )
                ),
                // --- Main UI (show only if gameStarted or skipOptions) ---
                (gameStarted || skipOptions) && React.createElement('div', { className: "min-h-screen flex flex-col items-center bg-gradient-to-br from-[#232946] via-[#1a2a3a] to-[#0a101a] py-8" },
                    React.createElement('div', { className: "flex flex-col items-center w-full max-w-5xl" },
                        // --- Felt background for flops ---
                        React.createElement('div', { className: "felt-bg p-4 md:p-8 mb-10 w-full rounded-xl" },
                            React.createElement('div', { className: "flex flex-col md:flex-row gap-10 justify-center" },
                                (firstFlop.exposed.length + (firstFlop.flipped?.length || 0) > 0)
                                    ? React.createElement(Flop, {
                                        flop: firstFlop,
                                        flopKey: "first_flop",
                                        onFlip: flipCard,
                                        prediction: predictionFirst,
                                        setPrediction: setPredictionFirst,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedFirst,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowFirst,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("first_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond,
                                        difficulty  // Add difficulty prop
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "First flop will appear here"),
                                (secondFlop && (secondFlop.exposed.length + (secondFlop.flipped?.length || 0) > 0))
                                    ? React.createElement(Flop, {
                                        flop: secondFlop,
                                        flopKey: "second_flop",
                                        onFlip: flipCard,
                                        prediction: predictionSecond,
                                        setPrediction: setPredictionSecond,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedSecond,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowSecond,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("second_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond,
                                        difficulty  // Add difficulty prop
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "Second flop will appear here")
                            )
                        ),
                        // --- Felt background for player hands ---
                        React.createElement('div', { className: "felt-bg p-1 md:p-4 lg:p-8 mb-10 w-full rounded-xl" },
                            gameStarted && React.createElement('div', {
                                className: "flex flex-wrap justify-center gap-1 md:gap-2 lg:gap-4 w-full"
                            },
                                players.length === 0
                                    ? React.createElement('div', { className: "text-white opacity-60" }, "No players yet. Start a game!")
                                    : players.map((player, idx) =>
                                        React.createElement(PlayerHand, { 
                                            key: idx, 
                                            player: player, 
                                            idx: idx,
                                            winningPlayers: currentWinners
                                        })
                                    )
                            )
                        )
                    ),
                    gameStarted &&
                    predictionFirst && predictionSecond &&
                    !winner &&
                    React.createElement('button', {
                        className: "poker-chip px-8 py-3 rounded-full text-lg mb-6",
                        onClick: () => revealWinner(),
                        style: { minWidth: 180 }
                    }, difficulty === "easy" ? "Check Answer" : "Skip to Results"),
                    // --- Show prediction accuracy ---
                    React.createElement('div', { className: "text-yellow-300 font-bold mb-2 text-lg" },
                        "Prediction Accuracy: ",
                        React.createElement('span', { className: "text-white" }, `${accuracy}%`),
                        React.createElement('span', { className: "text-gray-400 text-sm ml-2" }, `(${correctPredictions}/${totalPredictions})`),
                        totalPredictions > 0 && React.createElement('button', {
                            className: "ml-4 text-sm text-red-400 hover:text-red-300 underline",
                            onClick: resetPredictionAccuracy
                        }, "Reset")
                    ),
                    error && React.createElement('div', { className: "bg-red-200 text-red-800 rounded px-4 py-2 mb-4" },
                        typeof error === "string"
                            ? error
                            : "Could not reveal winner. Please try again."
                    ),
                    showResults && winner && React.createElement('div', { 
                        className: "bg-white bg-opacity-95 rounded-2xl p-8 shadow-2xl text-black mt-4 max-w-xl w-full border-4 border-yellow-400",
                        id: "game-results"  // Add ID for scrolling
                    },
                        React.createElement('h2', { className: "text-2xl font-bold mb-4 text-yellow-600" }, "Results"),
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "First Flop Winner:"),
                            React.createElement('div', null, 
                                Array.isArray(winner.winner_first) 
                                    ? winner.winner_first.join(" & ") + " (Tie)"
                                    : winner.winner_first,
                                " (", describeHandType(winner.hand_type_first), ")"
                            ),
                            winner.prediction_correct_first !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_first ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_first 
                                    ? (difficulty === "easy" ? "Correct!" : "Your prediction was correct!") 
                                    : (difficulty === "easy" ? "Incorrect!" : "Your prediction was incorrect."))
                        ),
                        winner.winner_second &&
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "Second Flop Winner:"),
                            React.createElement('div', null, 
                                Array.isArray(winner.winner_second) 
                                    ? winner.winner_second.join(" & ") + " (Tie)"
                                    : winner.winner_second,
                                " (", describeHandType(winner.hand_type_second), ")"
                            ),
                            winner.prediction_correct_second !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_second ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_second 
                                    ? (difficulty === "easy" ? "Correct!" : "Your prediction was correct!") 
                                    : (difficulty === "easy" ? "Incorrect!" : "Your prediction was incorrect."))
                        ),
                        React.createElement('div', { className: "flex gap-4 justify-center" },
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg mt-4",
                                onClick: resetGame
                            }, "Play Again"),
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg mt-4 ml-4",
                                onClick: goToGameOptions
                            }, "Game Options")
                        )
                    ),
                    // --- Add Leaderboard after results ---
                    showResults && React.createElement('div', { className: "mt-8 mb-8 flex flex-col items-center max-w-5xl w-full" },
                        React.createElement('h3', { className: "text-xl font-bold text-yellow-300 mb-2 text-center" }, 
                            `${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} Mode Leaderboard (20+ flops)`
                        ),
                        leaderboard && (!Array.isArray(leaderboard) || leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).length === 0)
                            ? React.createElement('div', { className: "text-gray-400 text-center" }, "No leaderboard entries yet.")
                            : React.createElement('table', { className: "text-sm bg-[#181e2a] bg-opacity-100 rounded-xl overflow-hidden border border-gray-700" },
                                React.createElement('thead', null,
                                    React.createElement('tr', { className: "bg-[#232946] text-yellow-300" },
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Rank"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Name"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Accuracy"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Flops"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Difficulty")
                                    )
                                ),
                                React.createElement('tbody', null,
                                    leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).map((entry, idx) =>
                                        React.createElement('tr', {
                                            key: `${entry.name}-${entry.difficulty}-${idx}`, // Add index to make key unique
                                            className:
                                                playerName.trim().toLowerCase() === entry.name.trim().toLowerCase() && entry.difficulty === difficulty
                                                    ? "bg-yellow-300 text-black font-bold"
                                                    : (idx % 2 === 0 ? "bg-[#232946] text-white" : "bg-[#181e2a] text-white")
                                        },
                                            React.createElement('td', { className: "px-4 py-2" }, idx + 1),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.name),
                                            React.createElement('td', { className: "px-4 py-2" },
                                                `${Math.round((entry.correct / entry.total) * 100)}%`
                                            ),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.total),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.difficulty ? entry.difficulty.charAt(0).toUpperCase() + entry.difficulty.slice(1) : "")
                                        )
                                    )
                                )
                            )
                    )
                ),
                // --- Game Rules at the very bottom, always rendered ---
                React.createElement('div', {
                    className: "rules-mobile bg-[#232946] bg-opacity-95 rounded-xl shadow-xl border-2 border-yellow-400 px-6 py-4 max-w-xs mx-auto mb-8 mt-8"
                },
                    React.createElement('h2', { className: "text-lg font-bold text-yellow-300 mb-2" }, "Game Rules:"),
                    React.createElement('ol', { className: "list-decimal list-inside text-white text-sm space-y-1" },
                        React.createElement('li', null, "Standard Texas Hold'em Rules in play."),
                        React.createElement('li', null, "Two cards of players hand MUST play."),
                        React.createElement('li', null, "The same two cards can be used for both hands."),
                        React.createElement('li', null, difficulty === "easy" 
                            ? "Easy Mode: All cards are shown. Select who won each flop." 
                            : "Difficult Mode: Predict winners before revealing cards."),
                        React.createElement('li', null, "The game will reset automatically after 20 flops are reached and your accuracy will be submitted to the leaderboard.")
                    )
                ),
                // Add admin link
                React.createElement('div', { className: "text-center mt-4 mb-8" },
                    React.createElement('a', {
                        href: "/admin",
                        className: "text-gray-500 hover:text-gray-400 text-sm underline"
                    }, "Admin")
                )
            );
        }

        // Attach scrollToGameOptions to window so it can be called from outside React
        window.scrollToGameOptions = function() {
            const el = document.getElementById('game-options');
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };

        // Move all debug logs to the very top of the script
        console.log("Bombpot Poker script loaded");
        console.log("React version:", window.React && window.React.version);
        console.log("ReactDOM version:", window.ReactDOM && window.ReactDOM.version);
        console.log("PokerGame typeof:", typeof PokerGame);

        // --- Fix: Ensure script runs after all functions are defined ---
        // Remove window.addEventListener('DOMContentLoaded', ...) and replace with direct call at end of script

        function renderPokerGame() {
            const rootEl = document.getElementById('root');
            console.log("renderPokerGame: #root exists?", !!rootEl, "innerHTML:", rootEl && rootEl.innerHTML);
            if (!rootEl) {
                console.error("No #root element found!");
                return;
            }
            if (!window.React || !window.ReactDOM) {
                console.error("React or ReactDOM not loaded!");
                rootEl.innerHTML = "<div style='color:red'>React failed to load. Check your CDN links.";
                return;
            }
            if (typeof PokerGame !== "function") {
                console.error("PokerGame is not defined or not a function. typeof PokerGame:", typeof PokerGame);
                rootEl.innerHTML = "<div style='color:red'>PokerGame is not defined. Check your script order.";
                return;
            }
            try {
                if (window.ReactDOM.createRoot) {
                    window.ReactDOM.createRoot(rootEl).render(React.createElement(PokerGame));
                } else {
                    window.ReactDOM.render(React.createElement(PokerGame), rootEl);
                }
                console.log("ReactDOM.render called"); // <-- Add this line
           
            } catch (e) {
                console.error("React render error:", e);
                rootEl.innerHTML = "<div style='color:red'>React render error: " + e + "</div>";
            }
        }

        // --- Call renderPokerGame directly at the end of the script ---
        renderPokerGame();

    </script>
</body>
</html>