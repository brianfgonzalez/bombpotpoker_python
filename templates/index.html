<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bombpot Poker</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: radial-gradient(ellipse at center, #1a2a3a 0%, #0a101a 100%);
            color: white;
            margin: 0;
            padding: 0;
        }
        /* Overlap cards in player hand, leftmost card on top */
        .overlap-cards {
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
        }
        .overlap-cards > * {
            margin-right: -1.7rem;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .overlap-cards > *:first-child {
            margin-right: 0;
        }
        /* Style for select dropdown to ensure readable text */
        .custom-select {
            background-color: #232946 !important;
            color: #fff !important;
            border: 1px solid #393e46;
        }
        /* Make all dropdown options white text on dark background */
        .custom-select option, select.custom-select option {
            background-color: #232946 !important;
            color: #fff !important;
        }
        /* Poker chip effect for buttons */
        .poker-chip {
            background: radial-gradient(circle at 60% 40%, #f7c873 0%, #eab308 80%, #b8860b 100%);
            color: #232946;
            border: 2px solid #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            font-weight: bold;
            letter-spacing: 1px;
            transition: transform 0.1s;
        }
        .poker-chip:hover {
            transform: scale(1.05);
            background: radial-gradient(circle at 60% 40%, #ffe082 0%, #facc15 80%, #b8860b 100%);
        }
        /* Card style enhancements */
        .poker-card {
            background: linear-gradient(135deg, #fff 60%, #e2e8f0 100%);
            border: 2px solid #393e46;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            color: #232946;
            transition: transform 0.6s cubic-bezier(0.4,2,0.2,1);
            transform-style: preserve-3d;
            perspective: 600px;
            min-height: 3.5rem; /* Ensure enough height for rank/suit */
        }
        .poker-card.flip-animate {
            transform: rotateY(180deg);
        }
        .poker-card.red {
            color: #e3342f;
            border-color: #e3342f;
        }
        .poker-card.black {
            color: #232946;
            border-color: #232946;
        }
        .poker-card.flipped {
            background: repeating-linear-gradient(
                135deg,
                #232946,
                #232946 10px,
                #393e46 10px,
                #393e46 20px
            );
            color: transparent;
            border-color: #393e46;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .overlap-cards > * {
                margin-right: -1.2rem;
            }
            .poker-card {
                min-height: 3rem !important;
            }
        }
        .reveal-glow {
            box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15;
            border-color: #ffe082 !important;
            background: linear-gradient(135deg, #ffe082 60%, #facc15 100%) !important;
            color: #232946 !important;
            animation: glow-pulse 1s infinite alternate;
        }
        .glow-select {
            box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9;
            border-color: #38bdf8 !important;
            background: linear-gradient(135deg, #38bdf8 60%, #0ea5e9 100%) !important;
            color: #fff !important;
            animation: glow-pulse-select 1s infinite alternate;
        }
        @keyframes glow-pulse {
            from { box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15; }
            to   { box-shadow: 0 0 6px 2px #ffe082, 0 0 9px 4px #facc15; }
        }
        @keyframes glow-pulse-select {
            from { box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9; }
            to   { box-shadow: 0 0 6px 2px #38bdf8, 0 0 9px 4px #0ea5e9; }
        }
        @media (max-width: 1024px) {
            .max-w-xs, .max-w-xl, .max-w-5xl, .max-w-7xl {
                max-width: 100vw !important;
            }
        }
        @media (max-width: 768px) {
            .overlap-cards > * {
                margin-right: -1.2rem;
            }
            .flex-col.md\:flex-row {
                flex-direction: column !important;
            }
            .gap-10 {
                gap: 1.5rem !important;
            }
            .px-4, .pt-6 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
                padding-top: 0.5rem !important;
            }
            .py-8 {
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
            }
            .mb-4, .mb-10 {
                margin-bottom: 1rem !important;
            }
            .rounded-xl {
                border-radius: 0.75rem !important;
            }
            .text-4xl {
                font-size: 2rem !important;
            }
            .text-lg {
                font-size: 1rem !important;
            }
            .w-14, .h-24 {
                width: 2.5rem !important;
                height: 3.5rem !important;
            }
            .p-6, .p-8 {
                padding: 1rem !important;
            }
            .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
        }
        @media (max-width: 500px) {
            .text-4xl {
                font-size: 1.3rem !important;
            }
            .text-lg {
                font-size: 0.9rem !important;
            }
            .w-14, .h-24 {
                width: 2rem !important;
                height: 3rem !important;
            }
            .rounded-xl {
                border-radius: 0.5rem !important;
            }
            .p-6, .p-8 {
                padding: 0.5rem !important;
            }
            .px-6, .px-8 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
            }
        }
        /* Responsive rules box */
        .rules-mobile {
            position: fixed;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 50;
        }
        @media (max-width: 768px) {
            .rules-mobile {
                position: static !important;
                margin: 0.5rem 0 1rem 0;
                width: 100%;
                max-width: 100vw !important;
                border-radius: 0.75rem !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/javascript">
        const { useState, useEffect, useRef } = React;

        function Card({ rank, suit, flipped, animate }) {
            const isRed = suit === "♥" || suit === "♦";
            const isBlack = suit === "♠" || suit === "♣";
            const cardRef = useRef(null);

            useEffect(() => {
                if (animate && cardRef.current) {
                    cardRef.current.classList.add('flip-animate');
                    const timeout = setTimeout(() => {
                        cardRef.current.classList.remove('flip-animate');
                    }, 600);
                    return () => clearTimeout(timeout);
                }
            }, [animate]);

            return (
                React.createElement('div', {
                    ref: cardRef,
                    className: `w-14 h-24 rounded-xl flex flex-col justify-between items-end px-2 py-1 poker-card ${isRed ? "red" : ""} ${isBlack ? "black" : ""} ${flipped ? "flipped" : ""} relative`
                },
                    !flipped && [
                        React.createElement('span', { className: "text-lg font-bold", key: "rank" }, rank),
                        React.createElement('span', { className: "text-xl", key: "suit" }, suit)
                    ]
                )
            );
        }

        function PlayerHand({ player, idx }) {
            return React.createElement('div', { className: "flex flex-col items-center mx-2 my-2" },
                React.createElement('span', { className: "mb-2 text-base font-semibold text-yellow-300 drop-shadow" }, `Player ${idx + 1}`),
                React.createElement('div', { className: "overlap-cards" },
                    player.cards.map((card, i) =>
                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit })
                    )
                )
            );
        }

        function Flop({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex, flops, highlightFourth, selectGlow, predictionOptions, canRevealFourth, predictionsLocked }) {
            // Show exposed and flipped cards in correct order, with flip animation for the last revealed
            const totalCards = (flop.exposed || []).length + (flop.flipped || []).length;
            const cards = [];
            const isTwoFlop = flops && flops.first_flop && flops.second_flop;
            const thisFlopFlipped = flop.flipped?.length || 0;
            const otherFlopFlipped = isTwoFlop
                ? flops[flopKey === "first_flop" ? "second_flop" : "first_flop"]?.flipped?.length || 0
                : 0;

            for (let i = 0; i < totalCards; i++) {
                if (i < (flop.exposed || []).length) {
                    cards.push(
                        React.createElement(Card, {
                            key: `exposed-${i}`,
                            rank: flop.exposed[i].rank,
                            suit: flop.exposed[i].suit,
                            flipped: false,
                            animate: lastFlippedIndex === i
                        })
                    );
                } else {
                    const flippedIdx = i - (flop.exposed || []).length;
                    let canReveal = true;
                    let extraClass = "";
                    // For the 4th card, only show "reveal" if canRevealFourth is true
                    if (thisFlopFlipped === 2 && flippedIdx === 0 && !canRevealFourth) {
                        canReveal = false;
                    }
                    // For the 5th card, only show "reveal" if both 4th cards are revealed
                    if (
                        isTwoFlop &&
                        thisFlopFlipped === 2 &&
                        flippedIdx === 1
                    ) {
                        canReveal = false;
                    }
                    if (
                        isTwoFlop &&
                        thisFlopFlipped === 1 &&
                        flippedIdx === 0 &&
                        (otherFlopFlipped > 1)
                    ) {
                        canReveal = false;
                    }
                    // Highlight the 4th card if requested and allowed
                    if (highlightFourth && thisFlopFlipped === 2 && flippedIdx === 0 && canRevealFourth) {
                        extraClass = "reveal-glow";
                    }
                    cards.push(
                        React.createElement('button', {
                            key: `flipped-${flippedIdx}`,
                            className:
                                "w-14 h-24 rounded-xl border-2 flex items-center justify-center font-bold mx-1 shadow-lg transition-all duration-300 " +
                                (canReveal ? (extraClass || "reveal-glow") : "border-gray-400 bg-gray-400 text-gray-200"),
                            onClick: canReveal ? () => onFlip(flopKey, flippedIdx) : undefined,
                            disabled: !canReveal,
                            "aria-label": "Flip card"
                        }, canReveal ? "reveal" : "")
                    );
                }
            }
            // Prediction dropdown options
            const options = predictionOptions || [];
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: `rounded px-2 py-1 custom-select ${selectGlow ? "glow-select" : ""}`,
                        value: prediction,
                        onChange: e => setPrediction(e.target.value),
                        disabled: predictionsLocked
                    },
                        React.createElement('option', { value: "", disabled: true, hidden: true }, "Select Player"),
                        options.length > 0
                            ? options.map(opt =>
                                React.createElement('option', { key: opt, value: opt }, opt)
                            )
                            : Array.from({ length: numPlayers }, (_, i) =>
                                React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                            )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" }, cards)
            );
        }

        function FlopWithAnimation({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex }) {
            // This version is used after a flip, to animate the newly revealed card
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: "rounded px-2 py-1 custom-select",
                        value: prediction,
                        onChange: e => setPrediction(e.target.value)
                    },
                        Array.from({ length: numPlayers }, (_, i) =>
                            React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                        )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" },
                    [
                        ...((flop.exposed || []).map((card, i) =>
                            React.createElement(Card, {
                                key: `exposed-${i}`,
                                rank: card.rank,
                                suit: card.suit,
                                flipped: false,
                                animate: lastFlippedIndex === i
                            })
                        ))
                    ]
                )
            );
        }

        function PokerGame() {
            const [players, setPlayers] = useState([]);
            const [firstFlop, setFirstFlop] = useState({ exposed: [], flipped: [] });
            const [secondFlop, setSecondFlop] = useState({ exposed: [], flipped: [] });
            const [numPlayers, setNumPlayers] = useState(2);
            const [difficulty, setDifficulty] = useState("easy");
            const [loading, setLoading] = useState(false);
            const [winner, setWinner] = useState(null);
            const [error, setError] = useState(null);
            const [predictionFirst, setPredictionFirst] = useState("");
            const [predictionSecond, setPredictionSecond] = useState("");
            const [gameStarted, setGameStarted] = useState(false);
            const [skipOptions, setSkipOptions] = useState(false);

            // Persistent tally state
            const [correctPredictions, setCorrectPredictions] = useState(() => Number(localStorage.getItem('correctPredictions')) || 0);
            const [totalPredictions, setTotalPredictions] = useState(() => Number(localStorage.getItem('totalPredictions')) || 0);
            const [lastFlippedFirst, setLastFlippedFirst] = useState(null);
            const [lastFlippedSecond, setLastFlippedSecond] = useState(null);
            const [allCardsRevealed, setAllCardsRevealed] = useState(false);
            const [highlightPrediction, setHighlightPrediction] = useState(true);
            const [highlightFourth, setHighlightFourth] = useState(false);
            const [predictionsLocked, setPredictionsLocked] = useState(false);

            // For auto-scroll
            const bottomRef = useRef(null);

            const startGame = async (skip = false) => {
                setLoading(true);
                setWinner(null);
                setError(null);
                try {
                    const resp = await fetch('/start_game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ num_players: numPlayers, num_flops: 2, difficulty })
                    });
                    if (!resp.ok) throw new Error("Failed to start game");
                    const data = await resp.json();
                    setPlayers(data.players);
                    setFirstFlop(data.first_flop);
                    setSecondFlop(data.second_flop);
                    setPredictionFirst("");
                    setPredictionSecond("");
                    setGameStarted(true);
                    setSkipOptions(skip);
                } catch (e) {
                    setError("Could not start game. Please try again.");
                }
                setLoading(false);
            };

            const flipCard = async (flopKey, idx) => {
                try {
                    if (flopKey === "first_flop") setLastFlippedFirst(null);
                    if (flopKey === "second_flop") setLastFlippedSecond(null);
                    const resp = await fetch('/reveal_card', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            flop: flopKey,
                            index: idx,
                            flops: {
                                first_flop: firstFlop,
                                second_flop: secondFlop
                            }
                        })
                    });
                    if (!resp.ok) throw new Error("Failed to flip card");
                    const data = await resp.json();
                    setFirstFlop(data.flops.first_flop);
                    setSecondFlop(data.flops.second_flop);
                    // Animate the newly revealed card
                    if (flopKey === "first_flop") setLastFlippedFirst((firstFlop.exposed.length) + idx);
                    if (flopKey === "second_flop") setLastFlippedSecond((secondFlop.exposed.length) + idx);
                } catch (e) {
                    setError("Could not flip card. Please try again.");
                }
            };

            const revealWinner = async () => {
                try {
                    const resp = await fetch('/reveal_winner', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            players,
                            first_flop: firstFlop.exposed.concat(firstFlop.flipped),
                            second_flop: secondFlop.exposed.concat(secondFlop.flipped),
                            prediction_first: predictionFirst,
                            prediction_second: predictionSecond
                        })
                    });
                    if (!resp.ok) throw new Error("Failed to reveal winner");
                    const data = await resp.json();

                    // Prediction accuracy logic
                    let correct = 0, total = 0;
                    if (data.winner_first) {
                        total += 1;
                        if (data.winner_first === predictionFirst) correct += 1;
                    }
                    if (data.winner_second) {
                        total += 1;
                        if (data.winner_second === predictionSecond) correct += 1;
                    }
                    setCorrectPredictions(prev => {
                        const val = prev + correct;
                        localStorage.setItem('correctPredictions', val);
                        return val;
                    });
                    setTotalPredictions(prev => {
                        const val = prev + total;
                        localStorage.setItem('totalPredictions', val);
                        return val;
                    });

                    setWinner(data);
                } catch (e) {
                    setError("Could not reveal winner. Please try again.");
                }
            };

            // Reset tally
            const resetTally = () => {
                setCorrectPredictions(0);
                setTotalPredictions(0);
                localStorage.setItem('correctPredictions', 0);
                localStorage.setItem('totalPredictions', 0);
            };

            // Auto-scroll to bottom when both flops have no flipped cards left
            const handleAllCardsRevealed = () => {
                setTimeout(() => {
                    if (bottomRef.current) {
                        bottomRef.current.scrollIntoView({ behavior: "smooth" });
                    }
                }, 200); // slight delay for animation
            };

            // Track when all cards are revealed for both flops
            useEffect(() => {
                if (
                    gameStarted &&
                    firstFlop &&
                    secondFlop &&
                    (firstFlop.flipped?.length === 0) &&
                    (secondFlop.flipped?.length === 0) &&
                    (firstFlop.exposed?.length + secondFlop.exposed?.length > 0)
                ) {
                    setAllCardsRevealed(true);
                } else {
                    setAllCardsRevealed(false);
                }
            }, [firstFlop, secondFlop, gameStarted]);

            // Reveal winner automatically when all cards are revealed and winner is not set
            useEffect(() => {
                if (allCardsRevealed && !winner) {
                    revealWinner();
                }
            }, [allCardsRevealed]);

            // Track when both predictions are made
            useEffect(() => {
                if (
                    highlightPrediction &&
                    predictionFirst &&
                    predictionSecond &&
                    predictionFirst !== "" &&
                    predictionSecond !== ""
                ) {
                    setHighlightPrediction(false);
                    setTimeout(() => setHighlightFourth(true), 200); // slight delay for effect
                }
            }, [predictionFirst, predictionSecond, highlightPrediction]);

            // Remove glow from dropdown as soon as a selection is made
            const selectGlowFirst = highlightPrediction && predictionFirst === "";
            const selectGlowSecond = highlightPrediction && predictionSecond === "";

            // When both 4th cards are revealed, stop highlighting
            useEffect(() => {
                if (
                    highlightFourth &&
                    firstFlop.flipped?.length < 2 &&
                    secondFlop.flipped?.length < 2
                ) {
                    setHighlightFourth(false);
                }
            }, [firstFlop.flipped, secondFlop.flipped, highlightFourth]);

            // Only allow revealing 4th cards if both predictions are selected
            const canRevealFourth = predictionFirst !== "" && predictionSecond !== "";

            // Lock predictions after the first card is revealed
            useEffect(() => {
                if (
                    gameStarted &&
                    (
                        (firstFlop.flipped && firstFlop.flipped.length < 2) ||
                        (secondFlop.flipped && secondFlop.flipped.length < 2)
                    )
                ) {
                    setPredictionsLocked(true);
                }
            }, [firstFlop.flipped, secondFlop.flipped, gameStarted]);

            // Reset prediction dropdowns and glow when starting next game
            const startGameWithReset = async (skip = false) => {
                setPredictionFirst("");
                setPredictionSecond("");
                setHighlightPrediction(true);
                setHighlightFourth(false);
                setPredictionsLocked(false);
                await startGame(skip);
            };

            // Fix: Always render the main UI, not just the error
            return React.createElement(
                React.Fragment,
                null,
                // --- Game Title and Rules Row ---
                React.createElement('div', { className: "w-full flex flex-col md:flex-row items-start justify-between px-4 pt-6 max-w-7xl mx-auto" },
                    React.createElement('h1', { className: "text-4xl font-extrabold text-yellow-400 mb-4 drop-shadow-lg tracking-wider" }, "Bombpot Poker"),
                    React.createElement('div', {
                        className: "rules-mobile bg-[#232946] bg-opacity-95 rounded-xl shadow-xl border-2 border-yellow-400 px-6 py-4 z-50 max-w-xs ml-4"
                    },
                        React.createElement('h2', { className: "text-lg font-bold text-yellow-300 mb-2" }, "Game Rules:"),
                        React.createElement('ol', { className: "list-decimal list-inside text-white text-sm space-y-1" },
                            React.createElement('li', null, "Standard Texas Holdum Rules in play."),
                            React.createElement('li', null, "Two cards of players hand MUST play."),
                            React.createElement('li', null, "The same two cards can be used for both hands.")
                        )
                    )
                ),
                // --- Prediction Accuracy and Reset Row ---
                React.createElement('div', { className: "mb-4 flex flex-col items-center w-full" },
                    React.createElement('div', { className: "flex flex-row items-center gap-2" },
                        React.createElement('div', { className: "text-white text-lg font-semibold mb-2" },
                            `Prediction Accuracy: ${totalPredictions > 0 ? Math.round((correctPredictions / totalPredictions) * 100) : 0}% (${correctPredictions}/${totalPredictions})`
                        ),
                        React.createElement('button', {
                            className: "poker-chip px-2 py-1 rounded-full text-base mb-2 flex items-center w-8 h-8 min-w-0 min-h-0",
                            style: { fontSize: "1.2rem", padding: 0 },
                            onClick: resetTally,
                            title: "Reset Prediction Accuracy"
                        },
                            React.createElement('svg', {
                                xmlns: "http://www.w3.org/2000/svg",
                                fill: "none",
                                viewBox: "0 0 24 24",
                                stroke: "currentColor",
                                className: "w-5 h-5"
                            },
                                React.createElement('path', {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    strokeWidth: 2,
                                    d: "M4 4v5h.582M20 20v-5h-.581M19.418 9A7.978 7.978 0 0012 4c-3.042 0-5.824 1.721-7.418 5M4.582 15A7.978 7.978 0 0012 20c3.042 0 5.824-1.721 7.418-5"
                                })
                            )
                        )
                    )
                ),
                // --- Game Options Floating Top ---
                (!gameStarted && !skipOptions) && React.createElement('div', {
                    className: "fixed top-0 left-0 w-full flex flex-col md:flex-row gap-10 justify-center z-40 bg-gradient-to-br from-[#232946] via-[#1a2a3a] to-[#0a101a] bg-opacity-95 pt-6 pb-4"
                },
                    React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-90 rounded-xl p-6 shadow-xl" },
                        React.createElement('label', { className: "text-white mb-2 text-lg font-semibold" }, "Number of Players:"),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select mb-4 text-base font-semibold",
                            value: numPlayers,
                            onChange: e => setNumPlayers(Number(e.target.value)),
                            disabled: loading
                        },
                            [2, 3, 4, 5, 6].map(n =>
                                React.createElement('option', { key: n, value: n }, n)
                            )
                        ),
                        React.createElement('label', { className: "text-white mb-2 text-lg font-semibold mt-2" }, "Select Difficulty:"),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select mb-4 text-base font-semibold",
                            value: difficulty,
                            onChange: e => setDifficulty(e.target.value),
                            disabled: loading
                        },
                            ["easy", "difficult"].map(level =>
                                React.createElement('option', { key: level, value: level }, level.charAt(0).toUpperCase() + level.slice(1))
                            )
                        ),
                        React.createElement('button', {
                            className: "poker-chip px-8 py-3 rounded-full text-lg mt-2",
                            onClick: () => startGame(false),
                            disabled: loading
                        }, loading ? "Dealing..." : "Start Game")
                    )
                ),
                // --- Main UI ---
                React.createElement('div', { className: "min-h-screen flex flex-col items-center bg-gradient-to-br from-[#232946] via-[#1a2a3a] to-[#0a101a] py-8" },
                    React.createElement('div', { className: "flex flex-col items-center w-full max-w-5xl" },
                        React.createElement('div', { className: "flex flex-col md:flex-row gap-10 mb-10 w-full justify-center" },
                            (firstFlop.exposed.length + (firstFlop.flipped?.length || 0) > 0)
                                ? React.createElement(Flop, {
                                    flop: firstFlop,
                                    flopKey: "first_flop",
                                    onFlip: flipCard,
                                    prediction: predictionFirst,
                                    setPrediction: setPredictionFirst,
                                    numPlayers,
                                    lastFlippedIndex: lastFlippedFirst,
                                    flops: { first_flop: firstFlop, second_flop: secondFlop },
                                    highlightFourth: highlightFourth,
                                    selectGlow: selectGlowFirst,
                                    predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                    canRevealFourth,
                                    predictionsLocked
                                })
                                : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "First flop will appear here"),
                            (secondFlop && (secondFlop.exposed.length + (secondFlop.flipped?.length || 0) > 0))
                                ? React.createElement(Flop, {
                                    flop: secondFlop,
                                    flopKey: "second_flop",
                                    onFlip: flipCard,
                                    prediction: predictionSecond,
                                    setPrediction: setPredictionSecond,
                                    numPlayers,
                                    lastFlippedIndex: lastFlippedSecond,
                                    flops: { first_flop: firstFlop, second_flop: secondFlop },
                                    highlightFourth: highlightFourth,
                                    selectGlow: selectGlowSecond,
                                    predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                    canRevealFourth,
                                    predictionsLocked
                                })
                                : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "Second flop will appear here")
                        ),
                        gameStarted && React.createElement('div', {
                            className: "flex flex-wrap justify-center gap-6 mb-10 w-full"
                        },
                            players.length === 0
                                ? React.createElement('div', { className: "text-white opacity-60" }, "No players yet. Start a game!")
                                : players.map((player, idx) =>
                                    React.createElement(PlayerHand, { key: idx, player: player, idx: idx })
                                )
                        )
                    ),
                    error && React.createElement('div', { className: "bg-red-200 text-red-800 rounded px-4 py-2 mb-4" },
                        typeof error === "string"
                            ? error
                            : "Could not reveal winner. Please try again."
                    ),
                    winner && React.createElement('div', { className: "bg-white bg-opacity-95 rounded-2xl p-8 shadow-2xl text-black mt-4 max-w-xl w-full border-4 border-yellow-400" },
                        React.createElement('h2', { className: "text-2xl font-extrabold mb-4 text-center text-green-700 tracking-wide" }, "Results"),
                        React.createElement('div', null,
                            React.createElement('div', { className: "mb-4" },
                                React.createElement('span', { className: "font-semibold" }, "First Flop Prediction: "),
                                React.createElement('span', { className: winner.winner_first === predictionFirst ? "text-green-600 font-bold" : "text-red-600 font-bold" },
                                    predictionFirst + (winner.winner_first === predictionFirst ? " (Correct)" : " (Incorrect)")
                                ),
                                React.createElement('br'),
                                React.createElement('span', { className: "font-semibold" }, "First Flop Winner: "), winner.winner_first,
                                React.createElement('br'),
                                React.createElement('span', { className: "font-semibold" }, "Hand: "), winner.hand_type_first,
                                React.createElement('div', { className: "flex mt-2" },
                                    winner.best_hand_first && winner.best_hand_first.map((card, i) =>
                                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit })
                                    )
                                )
                            ),
                            winner.winner_second && React.createElement('div', null,
                                React.createElement('span', { className: "font-semibold" }, "Second Flop Prediction: "),
                                React.createElement('span', { className: winner.winner_second === predictionSecond ? "text-green-600 font-bold" : "text-red-600 font-bold" },
                                    predictionSecond + (winner.winner_second === predictionSecond ? " (Correct)" : " (Incorrect)")
                                ),
                                React.createElement('br'),
                                React.createElement('span', { className: "font-semibold" }, "Second Flop Winner: "), winner.winner_second,
                                React.createElement('br'),
                                React.createElement('span', { className: "font-semibold" }, "Hand: "), winner.hand_type_second,
                                React.createElement('div', { className: "flex mt-2" },
                                    winner.best_hand_second && winner.best_hand_second.map((card, i) =>
                                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit })
                                    )
                                )
                            )
                        ),
                        React.createElement('div', { className: "flex flex-col md:flex-row gap-4 mt-6" },
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg w-full",
                                onClick: () => {
                                    setWinner(null);
                                    setGameStarted(false);
                                    setSkipOptions(false);
                                    setPlayers([]);
                                    setFirstFlop({ exposed: [], flipped: [] });
                                    setSecondFlop({ exposed: [], flipped: [] });
                                }
                            }, "Return to Game Options"),
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg w-full",
                                onClick: () => {
                                    setWinner(null);
                                    startGameWithReset(true);
                                }
                            }, "Start Next Game")
                        )
                    )
                )
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(PokerGame));
    </script>
</body>
</html>