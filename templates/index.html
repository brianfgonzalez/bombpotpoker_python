<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bombpot Poker</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Luckiest+Guy&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Montserrat', 'Segoe UI', 'Arial', sans-serif;
            background: #1a2a3a;
            background-image: url("/static/casino-felt.jpg");
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            color: #f3f4f6;
        }
        /* Overlap cards in player hand, leftmost card on top */
        .overlap-cards {
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
        }
        .overlap-cards > * {
            margin-right: -1.7rem;
            z-index: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
        .overlap-cards > *:first-child {
            margin-right: 0;
        }
        /* Style for select dropdown to ensure readable text */
        .custom-select {
            background-color: #232946 !important;
            color: #fff !important;
            border: 1px solid #393e46;
        }
        /* Make all dropdown options white text on dark background */
        .custom-select option, select.custom-select option {
            background-color: #232946 !important;
            color: #fff !important;
        }
        /* Poker chip effect for buttons */
        .poker-chip {
            background: radial-gradient(circle at 60% 40%, #f7c873 0%, #eab308 80%, #b8860b 100%);
            color: #232946;
            border: 2px solid #fff;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            font-weight: bold;
            letter-spacing: 1px;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .poker-chip:hover {
            transform: scale(1.05);
            background: radial-gradient(circle at 60% 40%, #ffe082 0%, #facc15 80%, #b8860b 100%);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        .poker-chip:active {
            transform: scale(0.97);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        /* Card style enhancements */
        .poker-card {
            background: linear-gradient(135deg, #fff 60%, #e2e8f0 100%);
            border: 2px solid #393e46;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            color: #232946;
            transition: transform 0.3s cubic-bezier(.4,2,.2,1), box-shadow 0.2s;
            transform-style: preserve-3d;
            perspective: 600px;
            min-height: 3.5rem; /* Ensure enough height for rank/suit */
            font-weight: bold;
        }
        .poker-card.flip-animate {
            transform: rotateY(180deg);
        }
        /* Remove hover effect for all .poker-card by default */
        /* .poker-card:hover {
            transform: scale(1.08) rotate(-2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            z-index: 2;
        } */
        /* Only apply hover effect for non-player cards if needed (handled in React) */
        .poker-card.red {
            color: #e3342f;
            border-color: #e3342f;
        }
        .poker-card.black {
            color: #232946;
            border-color: #232946;
        }
        .poker-card.blue {
            color: #2563eb;
            border-color: #2563eb;
        }
        .poker-card.green {
            color: #22c55e;
            border-color: #22c55e;
        }
        .poker-card.flipped {
            background: repeating-linear-gradient(
                135deg,
                #232946,
                #232946 10px,
                #393e46 10px,
                #393e46 20px
            );
            color: transparent;
            border-color: #393e46;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .overlap-cards > * {
                margin-right: -1.2rem;
            }
            .poker-card {
                min-height: 5.2rem !important;
                width: 4rem !important;
                height: 5.2rem !important;
            }
            .w-14, .h-24 {
                width: 4rem !important;
                height: 5.2rem !important;
            }
            .flex-col.md\:flex-row {
                flex-direction: column !important;
            }
            .gap-10 {
                gap: 1.5rem !important;
            }
            .px-4, .pt-6 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
                padding-top: 0.5rem !important;
            }
            .py-8 {
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
            }
            .mb-4, .mb-10 {
                margin-bottom: 1rem !important;
            }
            .rounded-xl {
                border-radius: 0.75rem !important;
            }
            .text-4xl {
                font-size: 2rem !important;
            }
            .text-lg {
                font-size: 1rem !important;
            }
            .w-14, .h-24 {
                width: 2.5rem !important;
                height: 3.5rem !important;
            }
            .p-6, .p-8 {
                padding: 1rem !important;
            }
            .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
        }
        .reveal-glow {
            box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15;
            border-color: #ffe082 !important;
            background: linear-gradient(135deg, #ffe082 60%, #facc15 100%) !important;
            color: #232946 !important;
            animation: glow-pulse 1s infinite alternate;
        }
        .glow-select {
            box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9;
            border-color: #38bdf8 !important;
            background: linear-gradient(135deg, #38bdf8 60%, #0ea5e9 100%) !important;
            color: #fff !important;
            animation: glow-pulse-select 1s infinite alternate;
        }
        @keyframes glow-pulse {
            from { box-shadow: 0 0 3px 1px #ffe082, 0 0 6px 2px #facc15; }
            to   { box-shadow: 0 0 6px 2px #ffe082, 0 0 9px 4px #facc15; }
        }
        @keyframes glow-pulse-select {
            from { box-shadow: 0 0 3px 1px #38bdf8, 0 0 6px 2px #0ea5e9; }
            to   { box-shadow: 0 0 6px 2px #38bdf8, 0 0 9px 4px #0ea5e9; }
        }
        @media (max-width: 1024px) {
            .max-w-xs, .max-w-xl, .max-w-5xl, .max-w-7xl {
                max-width: 100vw !important;
            }
        }
        @media (max-width: 500px) {
            .text-4xl {
                font-size: 1.3rem !important;
            }
            .text-lg {
                font-size: 0.9rem !important;
            }
            .w-14, .h-24 {
                width: 3.2rem !important;
                height: 4.2rem !important;
            }
            .poker-card {
                min-height: 4.2rem !important;
                width: 3.2rem !important;
                height: 4.2rem !important;
            }
            .rounded-xl {
                border-radius: 0.5rem !important;
            }
            .p-6, .p-8 {
                padding: 0.5rem !important;
            }
            .px-6, .px-8 {
                padding-left: 0.5rem !important;
                padding-right: 0.5rem !important;
            }
        }
        /* Responsive rules box */
        .rules-mobile {
            position: static !important;
            top: unset !important;
            right: unset !important;
            z-index: unset !important;
            margin: 2rem auto 2rem auto !important;
            width: 100%;
            max-width: 100vw !important;
            border-radius: 0.75rem !important;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        }
        @media (max-width: 1024px) {
            .rules-mobile {
                max-width: 95vw !important;
            }
        }
        @media (max-width: 768px) {
            .rules-mobile {
                position: static !important;
                margin: 0.5rem 0 1rem 0;
                width: 100%;
                max-width: 100vw !important;
                border-radius: 0.75rem !important;
                z-index: 1 !important;
            }
            .rules-mobile-spacer {
                display: none !important;
            }
        }
        .rules-mobile-placeholder {
            display: none;
        }
        @media (max-width: 768px) {
            .rules-mobile-placeholder {
                display: block;
                height: 0;
                margin: 0;
                padding: 0;
            }
        }
        h1, .game-title {
            font-family: 'Luckiest Guy', cursive, sans-serif;
            letter-spacing: 2px;
            text-shadow: 2px 2px 12px #000, 0 0 12px #ffe082;
            color: #ffe082;
            transition: color 0.2s, transform 0.2s;
        }
        .game-title:hover {
            color: #fffbe7;
            transform: scale(1.04);
        }
        /* Add a simple spinner for loading */
        .spinner {
            border: 4px solid #232946;
            border-top: 4px solid #ffe082;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
        .bg-opacity-80, .bg-opacity-90, .bg-opacity-95 {
            backdrop-filter: blur(2px) saturate(1.2);
        }
        .border-yellow-400 {
            box-shadow: 0 0 16px 2px #ffe08280;
        }
        .flex-col.items-center.mx-2.my-2:hover {
            background: rgba(46,204,113,0.08);
            border-radius: 0.75rem;
            box-shadow: 0 2px 12px 0 #ffe08240;
            transition: background 0.2s, box-shadow 0.2s;
        }
        /* Felt background for card and player hand containers */
        .felt-bg {
            background: url("/static/poker-felt.jpg");
            background-size: 300px 300px;
            background-repeat: repeat;
            background-position: center;
            border-radius: 1rem;
            box-shadow: 0 4px 24px 0 #00000040;
            border: 2px solid #2dd4bf;
            /* Add a subtle green overlay for depth */
            position: relative;
            overflow: hidden;
        }
        .felt-bg:before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(46,204,113,0.08) 0%, rgba(0,0,0,0.12) 100%);
            pointer-events: none;
            z-index: 1;
        }
        .felt-bg > * {
            position: relative;
            z-index: 2;
        }
        /* Optional: add a subtle overlay for contrast */
        .felt-bg-overlay {
            background: rgba(35,41,70,0.85);
            border-radius: 1rem;
        }
        /* Leaderboard improvements */
        table {
            border-radius: 0.75rem;
            overflow: hidden;
        }
        th, td {
            padding: 0.75rem 1rem;
        }
        th {
            background: #232946;
            color: #ffe082;
            font-weight: bold;
            letter-spacing: 1px;
        }
        tr:nth-child(even) {
            background: #232946;
        }
        tr:nth-child(odd) {
            background: #181e2a;
        }
        tr.bg-yellow-300 {
            background: #ffe082 !important;
            color: #232946 !important;
        }
        tr.bg-green-200 {
            background: #bbf7d0 !important;
            color: #232946 !important;
        }
        /* Button improvements */
        button:focus {
            outline: 2px solid #2dd4bf;
            outline-offset: 2px;
        }
        /* Responsive tweaks */
        @media (max-width: 768px) {
            .felt-bg {
                padding: 1rem !important;
            }
            .game-title {
                font-size: 2rem !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <noscript>
        <div style="color: #fff; background: #232946; padding: 2rem; border-radius: 1rem; text-align: center;">
            JavaScript is required to run Bombpot Poker.
        </div>
    </noscript>
    <script type="text/javascript">
        // Ensure React and ReactDOM are available
        const { useState, useEffect, useRef } = window.React;

        function Card({ rank, suit, flipped, animate, disableHover }) {
            // Color logic: hearts=red, spades=black, diamonds=blue, clubs=green
            const isRed = suit === "â™¥";
            const isBlack = suit === "â™ ";
            const isBlue = suit === "â™¦";
            const isGreen = suit === "â™£";
            const cardRef = useRef(null);

            useEffect(() => {
                if (animate && cardRef.current) {
                    cardRef.current.classList.add('flip-animate');
                    const timeout = setTimeout(() => {
                        cardRef.current.classList.remove('flip-animate');
                    }, 600);
                    return () => clearTimeout(timeout);
                }
            }, [animate]);

            // Compose className for color and hover
            let colorClass = "";
            if (isRed) colorClass = "red";
            else if (isBlack) colorClass = "black";
            else if (isBlue) colorClass = "blue";
            else if (isGreen) colorClass = "green";

            // Only add hover effect if disableHover is false
            const hoverClass = disableHover ? "" : "poker-card-hover";

            return (
                React.createElement('div', {
                    ref: cardRef,
                    className: `w-14 h-24 rounded-xl flex flex-col justify-between items-end px-2 py-1 poker-card ${colorClass} ${flipped ? "flipped" : ""} relative ${hoverClass}`
                },
                    !flipped && [
                        React.createElement('span', { className: "text-lg font-bold", key: "rank" }, rank),
                        React.createElement('span', { className: "text-xl", key: "suit" }, suit)
                    ]
                )
            );
        }

        function PlayerHand({ player, idx, winningPlayers }) {
            // Sort cards by suit first, then by rank from lowest to highest
            const suitOrder = ['â™£', 'â™¦', 'â™¥', 'â™ ']; // Clubs, Diamonds, Hearts, Spades
            const rankOrder = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            
            const sortedCards = [...player.cards].sort((a, b) => {
                // First sort by suit
                const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
                if (suitDiff !== 0) return suitDiff;
                // Then sort by rank (lowest to highest)
                return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank);
            });
            
            // Check if this player is winning any flop
            const playerName = `Player ${idx + 1}`;
            const isWinningFirst = winningPlayers?.first === playerName;
            const isWinningSecond = winningPlayers?.second === playerName;
            
            // Create separate container classes for each flop
            let containerClass = "flex flex-col items-center mx-2 my-2 p-3 rounded-lg transition-all duration-300 relative";
            
            // Add visual indicators for each flop separately
            const indicators = [];
            if (isWinningFirst) {
                indicators.push(React.createElement('div', { 
                    key: 'first-indicator',
                    className: "absolute -top-2 -left-2 bg-yellow-400 text-black rounded-full w-8 h-8 flex items-center justify-center font-bold text-xs shadow-lg z-10"
                }, "1st"));
            }
            if (isWinningSecond) {
                indicators.push(React.createElement('div', { 
                    key: 'second-indicator',
                    className: "absolute -top-2 -right-2 bg-blue-400 text-black rounded-full w-8 h-8 flex items-center justify-center font-bold text-xs shadow-lg z-10"
                }, "2nd"));
            }
            
            // Apply different styling based on which flop(s) they're winning
            if (isWinningFirst && isWinningSecond) {
                containerClass += " ring-4 ring-purple-400 bg-gradient-to-br from-yellow-400 to-blue-400 bg-opacity-20";
            } else if (isWinningFirst) {
                containerClass += " ring-4 ring-yellow-400 bg-yellow-400 bg-opacity-10";
            } else if (isWinningSecond) {
                containerClass += " ring-4 ring-blue-400 bg-blue-400 bg-opacity-10";
            }
            
            return React.createElement('div', { className: containerClass },
                ...indicators,
                React.createElement('span', { 
                    className: `mb-2 text-base font-semibold drop-shadow ${isWinningFirst || isWinningSecond ? 'text-white' : 'text-yellow-300'}` 
                }, 
                    playerName,
                    isWinningFirst && isWinningSecond && React.createElement('span', { className: "ml-2 text-xs" }, "ðŸ† Both"),
                    isWinningFirst && !isWinningSecond && React.createElement('span', { className: "ml-2 text-xs text-yellow-400" }, "ðŸ†"),
                    !isWinningFirst && isWinningSecond && React.createElement('span', { className: "ml-2 text-xs text-blue-400" }, "ðŸ†")
                ),
                React.createElement('div', { className: "overlap-cards" },
                    sortedCards.map((card, i) =>
                        // Pass disableHover=true for player cards
                        React.createElement(Card, { key: i, rank: card.rank, suit: card.suit, disableHover: true })
                    )
                )
            );
        }

        function Flop({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex, flops, highlightFourth, selectGlow, predictionOptions, canRevealFourth, predictionsLocked, predictionFirst, predictionSecond }) {
            // Show exposed and flipped cards in correct order, with flip animation for the last revealed
            const totalCards = (flop.exposed || []).length + (flop.flipped || []).length;
            const cards = [];
            const isTwoFlop = flops && flops.first_flop && flops.second_flop;
            const thisFlopFlipped = flop.flipped?.length || 0;
            const otherFlopFlipped = isTwoFlop
                ? flops[flopKey === "first_flop" ? "second_flop" : "first_flop"]?.flipped?.length || 0
                : 0;

            for (let i = 0; i < totalCards; i++) {
                if (i < (flop.exposed || []).length) {
                    cards.push(
                        React.createElement(Card, {
                            key: `exposed-${i}`,
                            rank: flop.exposed[i].rank,
                            suit: flop.exposed[i].suit,
                            flipped: false,
                            animate: lastFlippedIndex === i
                        })
                    );
                } else {
                    const flippedIdx = i - (flop.exposed || []).length;
                    let canReveal = false;
                    let extraClass = "";

                    // Only allow reveal if both predictions are made
                    if (predictionFirst && predictionSecond) {
                        // 4th card logic: thisFlopFlipped === 2 && flippedIdx === 0
                        if (thisFlopFlipped === 2 && flippedIdx === 0) {
                            canReveal = true;
                        }
                        // 5th card logic: thisFlopFlipped === 1 && flippedIdx === 0
                        else if (thisFlopFlipped === 1 && flippedIdx === 0) {
                            // Allow reveal if the other flop's 5th card is still unrevealed (flipped.length === 1)
                            // or if this is the only remaining 5th card
                            const otherFlopKey = flopKey === "first_flop" ? "second_flop" : "first_flop";
                            const otherFlopFlippedCount = flops[otherFlopKey]?.flipped?.length || 0;
                            if (otherFlopFlippedCount === 1 || otherFlopFlippedCount === 0) {
                                canReveal = true;
                            }
                        }
                    }

                    // Highlight the 4th card if requested and allowed
                    if (highlightFourth && thisFlopFlipped === 2 && flippedIdx === 0) {
                        extraClass = "reveal-glow";
                    }

                    cards.push(
                        React.createElement('button', {
                            key: `flipped-${flippedIdx}`,
                            className:
                                "w-14 h-24 rounded-xl border-2 flex items-center justify-center font-bold mx-1 shadow-lg transition-all duration-300 " +
                                (canReveal ? (extraClass || "reveal-glow") : "border-gray-400 bg-gray-400 text-gray-200"),
                            onClick: canReveal ? () => onFlip(flopKey, flippedIdx) : undefined,
                            disabled: !canReveal,
                            "aria-label": "Flip card"
                        }, canReveal ? "reveal" : "")
                    );
                }
            }
            // Prediction dropdown options
            const options = predictionOptions || [];
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: `rounded px-2 py-1 custom-select ${selectGlow ? "glow-select" : ""}`,
                        value: prediction,
                        onChange: e => setPrediction(e.target.value),
                        disabled: predictionsLocked
                    },
                        React.createElement('option', { value: "", disabled: true, hidden: true }, "Select Player"),
                        options.length > 0
                            ? options.map(opt =>
                                React.createElement('option', { key: opt, value: opt }, opt)
                            )
                            : Array.from({ length: numPlayers }, (_, i) =>
                                React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                            )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" }, cards)
            );
        }

        function FlopWithAnimation({ flop, flopKey, onFlip, prediction, setPrediction, numPlayers, lastFlippedIndex }) {
            // This version is used after a flip, to animate the newly revealed card
            return React.createElement('div', { className: "flex flex-col items-center bg-[#232946] bg-opacity-80 rounded-xl p-4 shadow-lg min-w-[220px]" },
                React.createElement('span', { className: "text-yellow-300 font-bold mb-2 text-lg tracking-wide" }, flopKey === "first_flop" ? "First Flop" : "Second Flop"),
                React.createElement('div', { className: "mb-3" },
                    React.createElement('label', { className: "text-white mr-2 font-medium" }, "Prediction:"),
                    React.createElement('select', {
                        className: "rounded px-2 py-1 custom-select",
                        value: prediction,
                        onChange: e => setPrediction(e.target.value)
                    },
                        Array.from({ length: numPlayers }, (_, i) =>
                            React.createElement('option', { key: i, value: `Player ${i + 1}` }, `Player ${i + 1}`)
                        )
                    )
                ),
                React.createElement('div', { className: "flex mt-2" },
                    [
                        ...((flop.exposed || []).map((card, i) =>
                            React.createElement(Card, {
                                key: `exposed-${i}`,
                                rank: card.rank,
                                suit: card.suit,
                                flipped: false,
                                animate: lastFlippedIndex === i
                            })
                        ))
                    ]
                )
            );
        }

        function describeHandType(handType, tiebreakers) {
            // Helper to add 's' to rank for pluralization
            function pluralRank(rank) {
                if (rank === "6") return "6s";
                if (rank === "7") return "7s";
                if (rank === "8") return "8s";
                if (rank === "9") return "9s";
                if (rank === "10") return "Tens";
                if (rank === "J") return "Js";
                if (rank === "Q") return "Qs";
                if (rank === "K") return "Ks";
                if (rank === "A") return "As";
                return rank + "s";
            }

            // Helper to convert rank to readable format
            function rankToWord(rank) {
                if (rank === "10") return "Ten";
                if (rank === "J") return "Jack";
                if (rank === "Q") return "Queen";
                if (rank === "K") return "King";
                if (rank === "A") return "Ace";
                return rank;
            }

            if (Array.isArray(handType) && handType.length === 3) {
                // Two Pair: [highPair, lowPair, kicker]
                return `Two Pairs ${pluralRank(handType[0])} and ${pluralRank(handType[1])}`;
            }
            if (Array.isArray(handType) && handType.length > 1) {
                // One Pair: [pair, kicker1, kicker2, ...]
                return `Pair of ${pluralRank(handType[0])}`;
            }
            // Check if it's a straight with high card info
            if (typeof handType === "string" && handType.startsWith("Straight")) {
                // Extract high card if provided (e.g., "Straight K" or "Straight, K high")
                const match = handType.match(/Straight[,\s]+([2-9JQKA]|10)/i);
                if (match && match[1]) {
                    return `${rankToWord(match[1])}-high Straight`;
                }
                return "Straight";
            }
            if (typeof handType === "string") {
                return handType;
            }
            return String(handType);
        }

        function PokerGame() {
            console.log("PokerGame rendering");
            // --- Restore all state hooks before any logic or return ---
            const [players, setPlayers] = useState([]);
            const [firstFlop, setFirstFlop] = useState({ exposed: [], flipped: [] });
            const [secondFlop, setSecondFlop] = useState({ exposed: [], flipped: [] });
            const [numPlayers, setNumPlayers] = useState(2);
            const [difficulty, setDifficulty] = useState("easy");
            const [loading, setLoading] = useState(false);
            const [winner, setWinner] = useState(null);
            const [error, setError] = useState(null);
            const [predictionFirst, setPredictionFirst] = useState("");
            const [predictionSecond, setPredictionSecond] = useState("");
            const [gameStarted, setGameStarted] = useState(false);
            const [skipOptions, setSkipOptions] = useState(false);
            const [correctPredictions, setCorrectPredictions] = useState(() => Number(localStorage.getItem('correctPredictions')) || 0);
            const [totalPredictions, setTotalPredictions] = useState(() => Number(localStorage.getItem('totalPredictions')) || 0);
            const [lastFlippedFirst, setLastFlippedFirst] = useState(null);
            const [lastFlippedSecond, setLastFlippedSecond] = useState(null);
            const [allCardsRevealed, setAllCardsRevealed] = useState(false);
            const [highlightPrediction, setHighlightPrediction] = useState(true);
            const [highlightFourth, setHighlightFourth] = useState(false);
            const [predictionsLocked, setPredictionsLocked] = useState(false);
            const [playerName, setPlayerName] = useState(() => localStorage.getItem('playerName') || "");
            const [nameHistory, setNameHistory] = useState(() => {
                const saved = localStorage.getItem('nameHistory');
                return saved ? JSON.parse(saved) : [];
            });
            const [leaderboard, setLeaderboard] = useState([]);
            const [leaderboardJustUpdated, setLeaderboardJustUpdated] = useState(false);
            const bottomRef = useRef(null);
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
            const [selectGlowFirst, setSelectGlowFirst] = useState(false);
            const [selectGlowSecond, setSelectGlowSecond] = useState(false);
            const [currentWinners, setCurrentWinners] = useState({ first: null, second: null });
            const [showResults, setShowResults] = useState(false);

            // --- FIX: Define isGameOptionsPage before using it ---
            const isGameOptionsPage = window.location.pathname === "/" || window.location.pathname === "/game-options";

            // Save player name to history when starting a game
            function saveNameToHistory(name) {
                if (!name.trim()) return;
                
                let history = [...nameHistory];
                // Remove if already exists
                history = history.filter(n => n.toLowerCase() !== name.toLowerCase());
                // Add to beginning
                history.unshift(name);
                // Keep only last 10
                history = history.slice(0, 10);
                
                setNameHistory(history);
                localStorage.setItem('nameHistory', JSON.stringify(history));
                localStorage.setItem('playerName', name);
            }

            // Add function to check current winners
            function updateCurrentWinners() {
                if (!gameStarted || players.length === 0) {
                    setCurrentWinners({ first: null, second: null });
                    return;
                }

                // Only calculate if predictions are made
                if (!predictionFirst || !predictionSecond) {
                    setCurrentWinners({ first: null, second: null });
                    return;
                }

                // Only use exposed cards (not flipped)
                const firstFlopCards = firstFlop.exposed?.length || 0;
                const secondFlopCards = secondFlop.exposed?.length || 0;

                // Show predicted winners immediately when predictions are made
                if (firstFlopCards === 3 && secondFlopCards === 3) {
                    // Only 3 cards exposed, just show predictions
                    setCurrentWinners({
                        first: predictionFirst,
                        second: predictionSecond
                    });
                    return;
                }

                // When we have 4 or 5 exposed cards, calculate actual winners
                if (firstFlopCards >= 4 || secondFlopCards >= 4) {
                    // Make API call to determine current winners based on exposed cards only
                    fetch('/reveal_winner', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            players,
                            first_flop: firstFlopCards >= 3 ? firstFlop.exposed : [],
                            second_flop: secondFlopCards >= 3 ? secondFlop.exposed : [],
                            prediction_first: predictionFirst || "temp",
                            prediction_second: predictionSecond || "temp"
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        setCurrentWinners({
                            first: firstFlopCards >= 3 ? data.winner_first : null,
                            second: secondFlopCards >= 3 ? data.winner_second : null
                        });
                    })
                    .catch(() => {
                        // On error, keep predictions as winners
                        setCurrentWinners({
                            first: predictionFirst,
                            second: predictionSecond
                        });
                    });
                }
            }

            // Update winners when predictions are made or cards are revealed
            useEffect(() => {
                if (gameStarted && !showResults) {
                    updateCurrentWinners();
                }
            }, [firstFlop.exposed, secondFlop.exposed, gameStarted, showResults, predictionFirst, predictionSecond]);

            // --- Add the startGame function inside PokerGame ---
            function startGame(skipLeaderboard = false) {
                // Save name to history
                if (playerName.trim()) {
                    saveNameToHistory(playerName.trim());
                }

                // Check if we've reached 20 flops and need to submit to leaderboard
                if (totalPredictions >= 20 && playerName.trim()) {
                    // Submit to leaderboard
                    fetch('/update_leaderboard', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: playerName.trim(),
                            correct: correctPredictions,
                            total: totalPredictions,
                            difficulty: difficulty
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            // Reset stats after submitting
                            setCorrectPredictions(0);
                            setTotalPredictions(0);
                            localStorage.setItem('correctPredictions', 0);
                            localStorage.setItem('totalPredictions', 0);
                            // Refresh leaderboard
                            fetch('/leaderboard')
                                .then(res => res.json())
                                .then(data => {
                                    setLeaderboard(data.leaderboard || []);
                                });
                        }
                    })
                    .catch(err => console.error("Failed to update leaderboard:", err));
                }

                setLoading(true);
                fetch('/start_game', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        num_players: numPlayers,
                        num_flops: 2
                    })
                })
                .then(res => {
                    if (!res.ok) {
                        throw new Error("Failed to start game.");
                    }
                    return res.json();
                })
                .then(data => {
                    // Defensive: check for valid data
                    if (!data.players || !data.first_flop) {
                        setError("Invalid response from server.");
                        setLoading(false);
                        return;
                    }
                    setPlayers(data.players || []);
                    setFirstFlop(data.first_flop || { exposed: [], flipped: [] });
                    setSecondFlop(data.second_flop || { exposed: [], flipped: [] });
                    setGameStarted(true);
                    setSkipOptions(skipLeaderboard);
                    setLoading(false);
                    setWinner(null);
                    setError(null);
                    setPredictionFirst("");
                    setPredictionSecond("");
                    setLastFlippedFirst(null);
                    setLastFlippedSecond(null);
                    setAllCardsRevealed(false);
                    setHighlightPrediction(true);
                    setHighlightFourth(false);
                    setPredictionsLocked(false);
                })
                .catch(err => {
                    setError("Failed to start game.");
                    setLoading(false);
                });
            }

            // --- Add resetPredictionAccuracy function ---
            function resetPredictionAccuracy() {
                if (confirm("Are you sure you want to reset your prediction accuracy? This will clear all your stats.")) {
                    setCorrectPredictions(0);
                    setTotalPredictions(0);
                    localStorage.setItem('correctPredictions', 0);
                    localStorage.setItem('totalPredictions', 0);
                }
            }

            // --- Add the flipCard function inside PokerGame ---
            function flipCard(flopKey, flippedIdx) {
                // Determine which flop to update
                const flops = {
                    first_flop: { ...firstFlop },
                    second_flop: { ...secondFlop }
                };
                // Defensive: check if the flop and flippedIdx are valid
                if (!flops[flopKey] || !Array.isArray(flops[flopKey].flipped) || flippedIdx >= flops[flopKey].flipped.length) {
                    setError("Invalid flop or card index.");
                    return;
                }
                // Only allow reveal if both predictions are made
                if (!predictionFirst || !predictionSecond) {
                    setError("Both player predictions must be made before revealing cards.");
                    return;
                }
                fetch('/reveal_card', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        flop: flopKey,
                        index: flippedIdx,
                        flops: flops,
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.error) {
                        setError(data.error);
                        return;
                    }
                    if (data.flops) {
                        if (data.flops.first_flop) setFirstFlop(data.flops.first_flop);
                        if (data.flops.second_flop) setSecondFlop(data.flops.second_flop);
                        setError(null);
                        // Update current winners after revealing a card
                        setTimeout(() => updateCurrentWinners(), 100);
                    }
                })
                .catch(() => setError("Failed to reveal card."));
            }

            // --- Add canRevealFourth helper ---
            function canRevealFourth(flopKey) {
                // Both flops must have at least 2 exposed + 1 flipped (i.e., 3 exposed, 1 flipped = 4th card available)
                // Only allow revealing the 4th card if both flops have not yet revealed their 4th card
                // For two-flop games, only allow revealing the 4th card if the other flop's 4th card is not already revealed
                if (!firstFlop || !secondFlop) return true;
                const thisFlop = flopKey === "first_flop" ? firstFlop : secondFlop;
                const otherFlop = flopKey === "first_flop" ? secondFlop : firstFlop;
                // If this flop has 2 exposed and 2 flipped, allow revealing the 4th card
                if ((thisFlop.exposed?.length === 3) && (thisFlop.flipped?.length === 2)) {
                    // Only allow if the other flop's flipped is also 2 (i.e., both ready for 4th card)
                    return (otherFlop.flipped?.length === 2);
                }
                // Otherwise, allow by default
                return true;
            }

            // --- Add the revealWinner function inside PokerGame ---
            function revealWinner() {
                setLoading(true);
                
                // Reveal all remaining cards before showing results
                const allFlops = {
                    first_flop: { ...firstFlop },
                    second_flop: { ...secondFlop }
                };
                
                // Move all flipped cards to exposed for both flops
                if (allFlops.first_flop.flipped && allFlops.first_flop.flipped.length > 0) {
                    allFlops.first_flop.exposed = [...allFlops.first_flop.exposed, ...allFlops.first_flop.flipped];
                    allFlops.first_flop.flipped = [];
                }
                if (allFlops.second_flop.flipped && allFlops.second_flop.flipped.length > 0) {
                    allFlops.second_flop.exposed = [...allFlops.second_flop.exposed, ...allFlops.second_flop.flipped];
                    allFlops.second_flop.flipped = [];
                }
                
                // Update the state to show all cards revealed
                setFirstFlop(allFlops.first_flop);
                setSecondFlop(allFlops.second_flop);
                
                fetch('/reveal_winner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        players,
                        first_flop: allFlops.first_flop.exposed,
                        second_flop: allFlops.second_flop.exposed,
                        prediction_first: predictionFirst,
                        prediction_second: predictionSecond
                    })
                })
                .then(res => res.json())
                .then(data => {
                    setWinner(data);
                    setShowResults(true);
                    setLoading(false);
                    setError(null);

                    // Update accuracy stats
                    let correct = correctPredictions;
                    let total = totalPredictions;
                    if (typeof data.prediction_correct_first === "boolean") {
                        total += 1;
                        if (data.prediction_correct_first) correct += 1;
                    }
                    if (typeof data.prediction_correct_second === "boolean") {
                        total += 1;
                        if (data.prediction_correct_second) correct += 1;
                    }
                    setCorrectPredictions(correct);
                    setTotalPredictions(total);
                    localStorage.setItem('correctPredictions', correct);
                    localStorage.setItem('totalPredictions', total);

                    // Check if we've reached 20 flops
                    if (total >= 20 && playerName.trim()) {
                        // Auto-submit to leaderboard
                        fetch('/update_leaderboard', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: playerName.trim(),
                                correct: correct,
                                total: total,
                                difficulty: difficulty
                            })
                        })
                        .then(res => res.json())
                        .then(submitData => {
                            if (submitData.success) {
                                // Show a message that stats were submitted
                                alert(`Congratulations! You've completed 20 flops with ${Math.round((correct / total) * 100)}% accuracy. Your score has been submitted to the leaderboard!`);
                                // Reset stats
                                setCorrectPredictions(0);
                                setTotalPredictions(0);
                                localStorage.setItem('correctPredictions', 0);
                                localStorage.setItem('totalPredictions', 0);
                                // Refresh leaderboard
                                fetch('/leaderboard')
                                    .then(res => res.json())
                                    .then(leaderboardData => {
                                        setLeaderboard(leaderboardData.leaderboard || []);
                                    });
                            }
                        })
                        .catch(err => console.error("Failed to update leaderboard:", err));
                    }
                })
                .catch(() => {
                    setError("Failed to reveal winner.");
                    setLoading(false);
                });
            }

            // --- Helper to reset for next round ---
            function resetGame() {
                setWinner(null);
                setShowResults(false);
                setPredictionFirst("");
                setPredictionSecond("");
                setPredictionsLocked(false);
                setHighlightFourth(false);
                setHighlightPrediction(true);
                setError(null);
                setAllCardsRevealed(false);
                setCurrentWinners({ first: null, second: null });
                startGame(true); // Automatically start new game with same options
            }

            // --- Add goToGameOptions function here ---
            function goToGameOptions() {
                setGameStarted(false);
                setSkipOptions(false);
                setWinner(null);
                setShowResults(false);
                setPredictionFirst("");
                setPredictionSecond("");
                setPredictionsLocked(false);
                setHighlightFourth(false);
                setHighlightPrediction(true);
                setError(null);
                setAllCardsRevealed(false);
                if (window.scrollToGameOptions) window.scrollToGameOptions();
            }

            // --- Add effect to glow prediction dropdowns until selected ---
            useEffect(() => {
                setSelectGlowFirst(!predictionFirst);
            }, [predictionFirst]);
            useEffect(() => {
                setSelectGlowSecond(!predictionSecond);
            }, [predictionSecond]);

            // --- Add effect to lock predictions after both are made ---
            useEffect(() => {
                if (predictionFirst && predictionSecond) {
                    setPredictionsLocked(true);
                    // Immediately show predicted winners
                    updateCurrentWinners();
                } else {
                    setPredictionsLocked(false);
                }
            }, [predictionFirst, predictionSecond]);

            // Add effect to fetch leaderboard on component mount
            useEffect(() => {
                fetch('/leaderboard')
                    .then(res => res.json())
                    .then(data => {
                        setLeaderboard(data.leaderboard || []);
                    })
                    .catch(err => console.error("Failed to fetch leaderboard:", err));
            }, []);

            // Update allCardsRevealed state when both flops have no flipped cards left
            useEffect(() => {
                if (
                    gameStarted &&
                    firstFlop.flipped.length === 0 &&
                    secondFlop.flipped.length === 0 &&
                    !allCardsRevealed
                ) {
                    setAllCardsRevealed(true);
                }
            }, [firstFlop.flipped, secondFlop.flipped, gameStarted]);

            // Trigger revealWinner when allCardsRevealed becomes true
            useEffect(() => {
                if (allCardsRevealed && !showResults && !winner && predictionFirst && predictionSecond) {
                    revealWinner();
                }
            }, [allCardsRevealed, showResults, winner, predictionFirst, predictionSecond]);

            // --- Add prediction accuracy calculation ---
            const accuracy = totalPredictions > 0 ? Math.round((correctPredictions / totalPredictions) * 100) : 0;

            // --- FIX: Always return a single parent, and use an array for children. Render game options/leaderboard as siblings to rules ---
            return React.createElement(
                'div',
                null,
                // --- Show banner/logo always with game options on the right ---
                React.createElement('div', {
                    className: "w-full flex flex-col md:flex-row items-center justify-between py-4 mb-4 px-4 bg-[#232946] bg-opacity-90"
                },
                    // Left side: Logo and title
                    React.createElement('div', {
                        className: "flex flex-col md:flex-row items-center"
                    },
                        React.createElement('a', {
                            href: "/",
                            onClick: (e) => {
                                e.preventDefault();
                                goToGameOptions();
                            },
                            className: "cursor-pointer"
                        },
                            React.createElement('img', {
                                src: "/static/logo.png",
                                alt: "Bombpot Poker Logo",
                                style: { width: 80, height: 80, marginRight: 16 },
                                className: "drop-shadow-lg hover:scale-105 transition-transform",
                                onError: (e) => {
                                    // Hide the image if it fails to load
                                    e.target.style.display = 'none';
                                }
                            })
                        ),
                        React.createElement('a', {
                            href: "/",
                            onClick: (e) => {
                                e.preventDefault();
                                goToGameOptions();
                            },
                            className: "cursor-pointer no-underline"
                        },
                            React.createElement('div', { className: "text-center md:text-left" },
                                React.createElement('h1', {
                                    className: "game-title text-2xl md:text-3xl font-extrabold tracking-wider"
                                }, "Bombpot Poker"),
                                React.createElement('div', {
                                    className: "text-yellow-300 text-sm md:text-base font-semibold tracking-wide"
                                }, "Texas Hold'em Bombpot Trainer")
                            )
                        )
                    ),
                    // Right side: Game options (only show if not in game)
                    (!gameStarted && !skipOptions) && React.createElement('div', {
                        className: "flex flex-col md:flex-row items-center gap-2 mt-4 md:mt-0"
                    },
                        React.createElement('div', { className: "relative" },
                            React.createElement('input', {
                                className: "rounded px-2 py-1 text-sm font-semibold bg-[#232946] border border-gray-400 text-white w-32",
                                type: "text",
                                value: playerName,
                                maxLength: 32,
                                placeholder: "Your name",
                                onChange: e => setPlayerName(e.target.value.replace(/[^a-zA-Z0-9 _-]/g, "")),
                                autoFocus: true,
                                list: "name-history"
                            }),
                            React.createElement('datalist', { id: "name-history" },
                                nameHistory.map(name => 
                                    React.createElement('option', { key: name, value: name })
                                )
                            )
                        ),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select text-sm font-semibold",
                            value: numPlayers,
                            onChange: e => setNumPlayers(Number(e.target.value)),
                            disabled: loading
                        },
                            [2, 3, 4, 5, 6].map(n =>
                                React.createElement('option', { key: n, value: n }, `${n} Players`)
                            )
                        ),
                        React.createElement('select', {
                            className: "rounded px-2 py-1 custom-select text-sm font-semibold",
                            value: difficulty,
                            onChange: e => setDifficulty(e.target.value),
                            disabled: loading
                        },
                            ["easy", "difficult"].map(level =>
                                React.createElement('option', { key: level, value: level }, level.charAt(0).toUpperCase() + level.slice(1))
                            )
                        ),
                        React.createElement('button', {
                            className: "poker-chip px-6 py-2 rounded-full text-sm",
                            onClick: () => startGame(false),
                            disabled: loading || !playerName.trim()
                        }, loading ? "Dealing..." : "Start Game")
                    )
                ),
                // Leaderboard (show if not started and not skipping options)
                (!gameStarted && !skipOptions) && React.createElement('div', { className: "mb-8 flex flex-col items-center" },
                    React.createElement('h3', { className: "text-xl font-bold text-yellow-700 mb-2 text-center" }, "Leaderboard (20+ flops)"),
                    leaderboard && (!Array.isArray(leaderboard) || leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).length === 0)
                        ? React.createElement('div', { className: "text-gray-600 text-center" }, "No leaderboard entries yet.")
                        : React.createElement('table', { className: "min-w-full text-sm bg-[#181e2a] bg-opacity-100 rounded-xl overflow-hidden border border-gray-700" },
                            React.createElement('thead', null,
                                React.createElement('tr', { className: "bg-[#232946] text-yellow-300" },
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Rank"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Name"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Accuracy"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Flops"),
                                    React.createElement('th', { className: "px-4 py-2 text-left" }, "Difficulty")
                                )
                            ),
                            React.createElement('tbody', null,
                                leaderboard.map((entry, idx) =>
                                    React.createElement('tr', {
                                        key: `${entry.name}-${entry.difficulty}-${idx}`, // Add index to make key unique
                                        className:
                                            playerName.trim().toLowerCase() === entry.name.trim().toLowerCase() && entry.difficulty === difficulty
                                                ? "bg-yellow-300 text-black font-bold"
                                                : (idx % 2 === 0 ? "bg-[#232946] text-white" : "bg-[#181e2a] text-white")
                                    },
                                        React.createElement('td', { className: "px-4 py-2" }, idx + 1),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.name),
                                        React.createElement('td', { className: "px-4 py-2" },
                                            `${Math.round((entry.correct / entry.total) * 100)}%`
                                        ),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.total),
                                        React.createElement('td', { className: "px-4 py-2" }, entry.difficulty ? entry.difficulty.charAt(0).toUpperCase() + entry.difficulty.slice(1) : "")
                                    )
                                )
                            )
                        )
                ),
                // --- Main UI (show only if gameStarted or skipOptions) ---
                (gameStarted || skipOptions) && React.createElement('div', { className: "min-h-screen flex flex-col items-center bg-gradient-to-br from-[#232946] via-[#1a2a3a] to-[#0a101a] py-8" },
                    React.createElement('div', { className: "flex flex-col items-center w-full max-w-5xl" },
                        // --- Felt background for flops ---
                        React.createElement('div', { className: "felt-bg p-4 md:p-8 mb-10 w-full rounded-xl" },
                            React.createElement('div', { className: "flex flex-col md:flex-row gap-10 justify-center" },
                                (firstFlop.exposed.length + (firstFlop.flipped?.length || 0) > 0)
                                    ? React.createElement(Flop, {
                                        flop: firstFlop,
                                        flopKey: "first_flop",
                                        onFlip: flipCard,
                                        prediction: predictionFirst,
                                        setPrediction: setPredictionFirst,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedFirst,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowFirst,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("first_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "First flop will appear here"),
                                (secondFlop && (secondFlop.exposed.length + (secondFlop.flipped?.length || 0) > 0))
                                    ? React.createElement(Flop, {
                                        flop: secondFlop,
                                        flopKey: "second_flop",
                                        onFlip: flipCard,
                                        prediction: predictionSecond,
                                        setPrediction: setPredictionSecond,
                                        numPlayers,
                                        lastFlippedIndex: lastFlippedSecond,
                                        flops: { first_flop: firstFlop, second_flop: secondFlop },
                                        highlightFourth: highlightFourth,
                                        selectGlow: selectGlowSecond,
                                        predictionOptions: Array.from({ length: numPlayers }, (_, i) => `Player ${i + 1}`),
                                        canRevealFourth: canRevealFourth("second_flop"),
                                        predictionsLocked,
                                        // --- Pass both predictions for reveal logic ---
                                        predictionFirst,
                                        predictionSecond
                                    })
                                    : gameStarted && React.createElement('div', { className: "text-white opacity-60 bg-[#232946] bg-opacity-80 rounded-xl p-6 shadow-lg min-w-[220px] text-center" }, "Second flop will appear here")
                            )
                        ),
                        // --- Felt background for player hands ---
                        React.createElement('div', { className: "felt-bg p-4 md:p-8 mb-10 w-full rounded-xl" },
                            gameStarted && React.createElement('div', {
                                className: "flex flex-wrap justify-center gap-6 w-full"
                            },
                                players.length === 0
                                    ? React.createElement('div', { className: "text-white opacity-60" }, "No players yet. Start a game!")
                                    : players.map((player, idx) =>
                                        React.createElement(PlayerHand, { 
                                            key: idx, 
                                            player: player, 
                                            idx: idx,
                                            winningPlayers: currentWinners
                                        })
                                    )
                            )
                        )
                    ),
                    gameStarted &&
                    predictionFirst && predictionSecond &&
                    !winner &&
                    React.createElement('button', {
                        className: "poker-chip px-8 py-3 rounded-full text-lg mb-6",
                        onClick: () => revealWinner(),
                        style: { minWidth: 180 }
                    }, "Skip to Results"),
                    // --- Show prediction accuracy ---
                    React.createElement('div', { className: "text-yellow-300 font-bold mb-2 text-lg" },
                        "Prediction Accuracy: ",
                        React.createElement('span', { className: "text-white" }, `${accuracy}%`),
                        React.createElement('span', { className: "text-gray-400 text-sm ml-2" }, `(${correctPredictions}/${totalPredictions})`),
                        totalPredictions > 0 && React.createElement('button', {
                            className: "ml-4 text-sm text-red-400 hover:text-red-300 underline",
                            onClick: resetPredictionAccuracy
                        }, "Reset")
                    ),
                    error && React.createElement('div', { className: "bg-red-200 text-red-800 rounded px-4 py-2 mb-4" },
                        typeof error === "string"
                            ? error
                            : "Could not reveal winner. Please try again."
                    ),
                    showResults && winner && React.createElement('div', { className: "bg-white bg-opacity-95 rounded-2xl p-8 shadow-2xl text-black mt-4 max-w-xl w-full border-4 border-yellow-400" },
                        React.createElement('h2', { className: "text-2xl font-bold mb-4 text-yellow-600" }, "Results"),
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "First Flop Winner:"),
                            React.createElement('div', null, winner.winner_first, " (", describeHandType(winner.hand_type_first), ")"),
                            winner.prediction_correct_first !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_first ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_first ? "Your prediction was correct!" : "Your prediction was incorrect.")
                        ),
                        winner.winner_second &&
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('div', { className: "font-semibold mb-1" }, "Second Flop Winner:"),
                            React.createElement('div', null, winner.winner_second, " (", describeHandType(winner.hand_type_second), ")"),
                            winner.prediction_correct_second !== undefined &&
                                React.createElement('div', {
                                    className: winner.prediction_correct_second ? "text-green-600 font-bold" : "text-red-600 font-bold"
                                }, winner.prediction_correct_second ? "Your prediction was correct!" : "Your prediction was incorrect.")
                        ),
                        React.createElement('div', { className: "flex gap-4 justify-center" },
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg mt-4",
                                onClick: resetGame
                            }, "Play Again"),
                            React.createElement('button', {
                                className: "poker-chip px-8 py-3 rounded-full text-lg mt-4 ml-4",
                                onClick: goToGameOptions
                            }, "Game Options")
                        )
                    ),
                    // --- Add Leaderboard after results ---
                    showResults && React.createElement('div', { className: "mt-8 mb-8 flex flex-col items-center max-w-5xl w-full" },
                        React.createElement('h3', { className: "text-xl font-bold text-yellow-300 mb-2 text-center" }, "Leaderboard (20+ flops)"),
                        leaderboard && (!Array.isArray(leaderboard) || leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).length === 0)
                            ? React.createElement('div', { className: "text-gray-400 text-center" }, "No leaderboard entries yet.")
                            : React.createElement('table', { className: "text-sm bg-[#181e2a] bg-opacity-100 rounded-xl overflow-hidden border border-gray-700" },
                                React.createElement('thead', null,
                                    React.createElement('tr', { className: "bg-[#232946] text-yellow-300" },
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Rank"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Name"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Accuracy"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Flops"),
                                        React.createElement('th', { className: "px-4 py-2 text-left" }, "Difficulty")
                                    )
                                ),
                                React.createElement('tbody', null,
                                    leaderboard.filter(e => e && typeof e.correct === "number" && typeof e.total === "number" && e.total >= 20).map((entry, idx) =>
                                        React.createElement('tr', {
                                            key: `${entry.name}-${entry.difficulty}-${idx}`, // Add index to make key unique
                                            className:
                                                playerName.trim().toLowerCase() === entry.name.trim().toLowerCase() && entry.difficulty === difficulty
                                                    ? "bg-yellow-300 text-black font-bold"
                                                    : (idx % 2 === 0 ? "bg-[#232946] text-white" : "bg-[#181e2a] text-white")
                                        },
                                            React.createElement('td', { className: "px-4 py-2" }, idx + 1),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.name),
                                            React.createElement('td', { className: "px-4 py-2" },
                                                `${Math.round((entry.correct / entry.total) * 100)}%`
                                            ),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.total),
                                            React.createElement('td', { className: "px-4 py-2" }, entry.difficulty ? entry.difficulty.charAt(0).toUpperCase() + entry.difficulty.slice(1) : "")
                                        )
                                    )
                                )
                            )
                    )
                ),
                // --- Game Rules at the very bottom, always rendered ---
                React.createElement('div', {
                    className: "rules-mobile bg-[#232946] bg-opacity-95 rounded-xl shadow-xl border-2 border-yellow-400 px-6 py-4 max-w-xs mx-auto mb-8 mt-8"
                },
                    React.createElement('h2', { className: "text-lg font-bold text-yellow-300 mb-2" }, "Game Rules:"),
                    React.createElement('ol', { className: "list-decimal list-inside text-white text-sm space-y-1" },
                        React.createElement('li', null, "Standard Texas Holdum Rules in play."),
                        React.createElement('li', null, "Two cards of players hand MUST play."),
                        React.createElement('li', null, "The same two cards can be used for both hands."),
                        React.createElement('li', null, "The game will reset automatically after 20 flops are reached and your accuracy will be submitted to the leaderboard.")
                    )
                )
            );
        }

        // Attach scrollToGameOptions to window so it can be called from outside React
        window.scrollToGameOptions = function() {
            const el = document.getElementById('game-options');
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };

        // Move all debug logs to the very top of the script
        console.log("Bombpot Poker script loaded");
        console.log("React version:", window.React && window.React.version);
        console.log("ReactDOM version:", window.ReactDOM && window.ReactDOM.version);
        console.log("PokerGame typeof:", typeof PokerGame);

        // --- Fix: Ensure script runs after all functions are defined ---
        // Remove window.addEventListener('DOMContentLoaded', ...) and replace with direct call at end of script

        function renderPokerGame() {
            const rootEl = document.getElementById('root');
            console.log("renderPokerGame: #root exists?", !!rootEl, "innerHTML:", rootEl && rootEl.innerHTML);
            if (!rootEl) {
                console.error("No #root element found!");
                return;
            }
            if (!window.React || !window.ReactDOM) {
                console.error("React or ReactDOM not loaded!");
                rootEl.innerHTML = "<div style='color:red'>React failed to load. Check your CDN links.";
                return;
            }
            if (typeof PokerGame !== "function") {
                console.error("PokerGame is not defined or not a function. typeof PokerGame:", typeof PokerGame);
                rootEl.innerHTML = "<div style='color:red'>PokerGame is not defined. Check your script order.";
                return;
            }
            try {
                if (window.ReactDOM.createRoot) {
                    window.ReactDOM.createRoot(rootEl).render(React.createElement(PokerGame));
                } else {
                    window.ReactDOM.render(React.createElement(PokerGame), rootEl);
                }
                console.log("ReactDOM.render called"); // <-- Add this line
            } catch (e) {
                console.error("React render error:", e);
                rootEl.innerHTML = "<div style='color:red'>React render error: " + e + "</div>";
            }
        }

        // --- Call renderPokerGame directly at the end of the script ---
        renderPokerGame();

    </script>
</body>
</html>